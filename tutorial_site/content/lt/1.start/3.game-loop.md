---
title: 'Žaidimo ciklas'
description: 'Tutorial about PyGame Cycles'
---

(*angl. game loop*)

## PyGame dokumentacija

Jau pasiruošėme pradėti programuoti žaidimą. Toliau medžiaga remsis PyGame oficialia [dokumentacija](https://www.pygame.org/docs/). Dokumentacija atlieka labai svarbų vaidmenį kuriant ir prižiūrint programinę įrangą. Joje galima rasti aprašytas bibliotekos galimybes, pamokas, apribojimu, efektyvaus naudojimo patarimų.

## Pirmas žaidimų langas

Dabar paleiskime pirmą kodą, kuris pateiktas dokumentacijoje. Šio kodo pagalba, mes paleisime žaidimų langą.

```python
# Example file showing a basic pygame "game loop"
import pygame

# pygame setup
pygame.init()
screen = pygame.display.set_mode((1280, 720))
clock = pygame.time.Clock()
running = True

while running:
    # poll for events
    # pygame.QUIT event means the user clicked X to close your window
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # fill the screen with a color to wipe away anything from last frame
    screen.fill("purple")

    # RENDER YOUR GAME HERE

    # flip() the display to put your work on screen
    pygame.display.flip()

    clock.tick(60)  # limits FPS to 60

pygame.quit()
```

Turėjo atsidaryti tuščias purpurinis stačiakampis programos langas. Toliau paanalizuokime šį kodą eilutę po eilutę. Su pirmąją elute kode, mes importuojame pygame biblioteka, kad galėtume ją vėliau panaudoti kode.

```python
import pygame
```

Toliau inicializuojame pygame su `pygame.init()`{lang="python"} ([dokumentacija](https://www.pygame.org/docs/ref/pygame.html#pygame.init)). Iškvietus šią funkciją, inicializuojami visi pygame moduliai. Toliau sukuriamas ekrano kintamasis, kaip argumentą pateikiame šio ekrano dydį ([dokumentacija](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode)). Šį kintamąjį geriau būtų įsivaizduoti, kaip tuščią drobę, kurioje galima piešti figūras, animacinius objektus (ang. sprites) ir tekstą. Reiktų suprasti, kad „piešimą“  atliksime programuodami. Paskutinėje eilutėje sukuriame laikrodžio *Clock* objektą, šis naudojamas „laikui stebėti“. Laikrodis taip pat atlieka keletą funkcijų, padedančių valdyti žaidimo kadrų spartą ([dokumentacija](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock)).

```python
# pygame setup
pygame.init()
screen = pygame.display.set_mode((1280, 720))
clock = pygame.time.Clock()
running = True
```

Prieš pat ciklą `while`{lang="python"}, sukuriame `bool`{lang="python"} tipo kintamąjį `running = True`{lang="python"}, kuris nurodys mums, ar žaidimas vis dar veikia. Toliau seka pagrindinė žaidimo kodo blokas - žaidimo ciklas. Šiame bloke aprašomas kiekvieno žaidimo momento (angl. tick) veiksmai, komandos. Šis ciklas veiks tol, kol `running`{lang="python"} kintamasis bus `True`{lang="python"}. Ciklai `while`{lang="python"} aprašomi taip:

```python
while sąlyga:
    veiksmas1()
    veiksmas2()
    ...
    veiksmasN()
```

Žaidimo cikle pirmiausia patikrinami žaidimo įvykis, ar žaidimas išjungiamas ( `event.type == pygame.QUIT`{lang="python"}). Visus *pygame*  įvykius rasite [dokumentacijoje](https://www.pygame.org/docs/ref/event.html). Kaip yra išjungiamas žaidimo langas (paspaudžias *X* mygtukas), tokiu atveju mes nustatome `running = False`{lang="python"} ir taip baigiamas žaidimo ciklas.

```python
# ...
running = True

while running:
    # poll for events
    # pygame.QUIT event means the user clicked X to close your window
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # ...
```

Ryškios spalvos violetinį ekraną padarome su [screen.fill(color, ...)](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.fill) funkcija. Šiuo atveju užpildoma spalva *purple*, kuri yra iš anksto sukurta. Spalvas galima nurodyti iš [sąrašo](https://www.pygame.org/docs/ref/color_list.html) arba nurodydami raudonos, žalios, mėlynos spalvų įverčius iki 255, toks formatas dar vadinamas *RGB*. Pavyzdžiui vietoj *"purple"* įrašę (0, 0, 255), gautume mėlynos spalvos ekraną. Mėlynos spalvos ekraną taip pat galima gauti įrašę vietoj argumento *"blue"*.

```python
    # ...code before

    # fill the screen with a color to wipe away anything from last frame
    screen.fill("purple")

    # ...code after
```

Braižymas, piešimas žaidimo lange vyksta netiesiogiai. Pirmiausia, visi grafiniai skaičiavimai, vaizdų piešimai vyksta ne ekrane, o ant *surface*. Atlikus visas grafinių vaizdų transformacijas, pokyčius, piešimus, šis *surface* perkeliamas į ekraną ([dokumentacija](https://www.pygame.org/docs/ref/display.html#pygame.display.flip)). Tai padaroma su žemiau pateikta kodo eilute:

```python
    # ...code before

    # flip() the display to put your work on screen
    pygame.display.flip()
    
    # ...code after
```

Žaidimuose vientisas vaizdas gaunamas rodant daug kadrų iš eilės. Atskirų kadrų nematome, kadangi vaizdas atnaujinamas daug kartų per sekundę. Rodiklis rodantis kiek kartų kadrų parodoma per sekundę vadinamas kadrai per sekundę (*angl. frames per second, fps*). Šį rodiklį, mes limituosime iki 60, kad išvengtume perteklinio kompiuterio resursų, žaidimas būtų stabilesnis.

```python
    # ...code before

    clock.tick(60)  # limits FPS to 60
    
    # ...code after
```

## Pozicija žaidimų lange

Prieš nagrinėjant kitą dokumentacijoje pateiktą pavyzdį, aptarsime, kaip nurodoma objektų (primityvių figūrų, paveiksliukų, pelės žymeklio ir kt.) pozicija žaidimo lange. Pasileiskime anksčiau pateiktą, bet modifikuotą pavyzdį:

```python
# Example file showing a basic pygame "game loop"
import pygame

# pygame setup
pygame.init()
screen = pygame.display.set_mode((1280, 720))
clock = pygame.time.Clock()
running = True

while running:
    # poll for events
    # pygame.QUIT event means the user clicked X to close your window
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        # Mouse click coordinates
        if event.type == pygame.MOUSEBUTTONDOWN:
            x = pygame.mouse.get_pos()[0]
            y = pygame.mouse.get_pos()[1]
            print(f"(x,y)=({x},{y})")

    # fill the screen with a color to wipe away anything from last frame
    screen.fill("purple")

    # RENDER YOUR GAME HERE

    # flip() the display to put your work on screen
    pygame.display.flip()

    clock.tick(60)  # limits FPS to 60

pygame.quit()
```

Paspaudinėkite ant žaidimo lango su pelyte, konsolėje turėtumėte pamatyti kažką panašaus į tai $$(x,y)=(965,456)$$. Modifikacija leidžia paspaudus ant kažkurios vietos lange, konsoliniame lange parodo, kurioje pozicijoje buvo paspausta su pelyte. Ši pozicija nurodoma dviem reikšmėmis: $$x$$ ir $$y$$ koordinatėmis. Koordinatė $$x$$ nurodo, kiek objektas (šiuo atveju pelės žymeklis paspaudimo metu) nutolęs nuo kairiojo lango krašto, tai nepriklauso nuo to, kaip žemai, ar aukštai tas objektas tas yra. Koordinatė y nurodo, kiek objektas nutolęs nuo viršutiniojo lango krašto, tai nepriklauso, kiek kairėn ar dešinėn tas objektas yra. Kuo didesnė $$x$$ koordinatės reikšmė, tuo objektas yra labiau dešinėje. Kuo didesnė $$y$$ koordinatės reikšmė, tuo objektas yra žemiau. Tokius $$x$$ ir $$y$$ koordinačių pokyčius galima atvaizduoti su koordinačių plokštuma. Ši šiek tiek skiriasi nuo tos, kurios mokoma mokyklos kurse (stačiakampės koordinačių sistemos, dekarto plokštumos). Šią vaizduosime konkrečiu atveju -  dabartinės žaidimo lango, kuris yra 1280 pikselių ilgio ir 720 pikselių pločio. Tik pakeisime žaidimo fono spalvą į pilką.

![Koordinačių sistema žaidimo lange](/content_images/coordinate_system_window.png "Koordinačių sistema žaidimo lange"){ height=550 }

Jau turėtumėte žinoti, kad daugelis dalykų programavime skaičiuojami nuo nulio. Koordinačių reikšmės taip pat prasideda nuo nulio. Todėl galinės koordinačių reikšmės yra vienu mažesnės negu nustatytos reikšmės. Nustatėme, kad lango ilgis būtų $$1280$$ pikselių ilgio, bet dešiniausios koordinatės $$x$$ reikšmė yra $$1279$$. Jeigu daug išbandinėjote spaudinėjimą ant žaidimo lango ir stebėjote, kaip keičiaisi koordinatės, galėjote pastebėti, kad tiek x, tiek y reikšmės visada būna sveiki skaičiai. Jeigu bandysite nustatyti objekto koordinates su trupmeniniu skaičiu, tai šio skaičiaus dalis po kablelio bus ignoruojama, pašalinama (angl. *truncated*). Pavyzdžiui $$1.5$$ taps $$1$$, $$1945.5$$ taps $$1945$$ ir t.t.

Objektas gali turėti ir neigiamas koordinates arba tokias, kurios yra didesnės negu lango ilgis ir plotis. Tokiu atveju objektas bus piešiamas kažkur tai už lango. Tokį atvejį mes pamatysime vėliau. Dabar paanalizuokime kitą dokumentacijoje esantį kodo pavyzdį.

## Įvesties įvykiai ir jų apdorojimas

Įvykius jau naudojome anksčiau. Pavyzdžiuose galėtjo pamatyti `event.type == pygame.MOUSEBUTTONDOWN`{lang="python"} ir `event.type == pygame.QUIT`{lang="python"}.

Kuriant žaidimus su *Pygame*, kiekvieną kartą paspaudus klaviatūros klavišą ar pelės mygtuką įvyksta įvykis (*angl. event*). *Pygame* registruoja kiekvieną įvykį ir talpina jį sąraše. Kuriant žaidimą, reikės dirbti su šiuo įvykių sąrašu ir pagal šiuos įvykius vykdyti instrukcijas.

Pavyzdžiui, paspaudus mygtuką :keyboard-keys{:keys='["↑"]'}, *Pygame* užregistruoja šį paspaudimo įvykį ir prideda į sąrašą, kaip „aukštyn mygtukas buvo paspaustas“. O tada galima patikrinti, ar toks mygtukas buvo paspaustas ir, pavyzdžiui, galima padaryti, kad veikėjas pašoktų.

### Kodas

Įvestiems įvykiams panagrinėti, analizuosime kodą, kuris pateiktas dokumentacijoje pateiktas sekantis:

```python
# Example file showing a circle moving on screen
import pygame

# pygame setup
pygame.init()
screen = pygame.display.set_mode((1280, 720))
clock = pygame.time.Clock()
running = True
dt = 0

player_pos = pygame.Vector2(screen.get_width() / 2, screen.get_height() / 2)

while running:
    # poll for events
    # pygame.QUIT event means the user clicked X to close your window
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # fill the screen with a color to wipe away anything from last frame
    screen.fill("purple")

    pygame.draw.circle(screen, "red", player_pos, 40)

    keys = pygame.key.get_pressed()
    if keys[pygame.K_w]:
        player_pos.y -= 300 * dt
    if keys[pygame.K_s]:
        player_pos.y += 300 * dt
    if keys[pygame.K_a]:
        player_pos.x -= 300 * dt
    if keys[pygame.K_d]:
        player_pos.x += 300 * dt

    # flip() the display to put your work on screen
    pygame.display.flip()

    # limits FPS to 60
    # dt is delta time in seconds since last frame, used for framerate-
    # independent physics.
    dt = clock.tick(60) / 1000

pygame.quit()
```

Pasileiskite, turėtumėte pamatyti apskritimą viduryje ekrano, pasinaudojus :keyboard-keys{:keys='["W", "A", "S", "D"]' any} klavišais turėtumėte galėti jį valdyti.

![Descriptive text](/content_images/moving_circle.gif){ height=300 format="gif"}

### Kodo analizė

Pirmosios kelios eilutės sutampa su prieš tai analizuotų kodu, tik čia papildomai inicializuojamas kintamasis `dt = 0`{lang="python"}. Šio kintamojo reikšmę kodui aptarsime vėliau, o kol kas laikykite tai skirtumas tarp dviejų laiko momentų.

Toliau sutinkame ir sekančio kintamojo sukūrimą `player_pos`{lang="python"}. Šio kintamojo vardas reiškia *player position*. Šį kintamąjį naudosime saugoti žaidėjo pozicijai. Jo pradinė reikšmė nustatoma žaidimo lango centro koordinatės. Nors šio kintamojo tipo atikmuo matematikoje yra vektorius, kol kas tai laikyime, kaip taško koordinates (x, y). *Vector2* naudojamas:

- veiksmams su judėjimu;
- objektų fizikai aprašyti;
- susidūrimų identifikavimui;
- krypčiai ir atstumui nustatyti;

Šie dalykai turėtų skambėti sudėtingai, tai kol kas į juos nesigilinkime ir analizuokime kodą toliau.

```python
# ...
    pygame.draw.circle(screen, "red", player_pos, 40)
# ...

```

Nuspalvinus ekraną purpurine spalva, ekrane nupiešiamas raudonas apskritimas, kurios spindulys yra $$40$$, o pozicija tokia pat, kaip `player_pos`{lang="python"} reikšmė - pirmame žaidimo kadre, tai žaidimo lango centras. Daugiau informacijos apie skritulių, apskritimų braižymą rasite [dokumentacijoje](https://www.pygame.org/docs/ref/draw.html#pygame.draw.circle).

```python
# ...
    # ...
    keys = pygame.key.get_pressed()
    if keys[pygame.K_w]:
        player_pos.y -= 300 * dt
    if keys[pygame.K_s]:
        player_pos.y += 300 * dt
    if keys[pygame.K_a]:
        player_pos.x -= 300 * dt
    if keys[pygame.K_d]:
        player_pos.x += 300 * dt

    # ...

    # limits FPS to 60
    # dt is delta time in seconds since last frame, used for framerate-
    # independent physics.
    dt = clock.tick(60) / 1000

# ...
```

Pateiktas kodo fragmentas leidžia valdyti apskritimą į visas kryptis. Su `keys = pygame.key.get_pressed()`{lang=python} eilute, sukuriamas kintamasis, per kurį galima pasiekti visus mygtukų paspaudimo įvykius. Sukurtas kintamasis yra [*dictionary*](https://www.w3schools.com/python/python_dictionaries.asp) tipo. Kol kas šio tipo neanalizuosime, bet reiktų žinoti, jeigu norime sužinoti, ar mygtukas paspaustas reikia naudoti \[ \] skliaustelius, juose nurodant mygtuką. Pavyzdžiui:

```python
keys = pygame.key.get_pressed()
is_w_pressed = keys[pygame.K_w] 
print(f"is w key pressed: ${is_w_pressed}")
# Print the state of the 'W' key. The output will be:
# "is W key pressed: True"
# or
# "is W key pressed: False"
# depending on whether the 'W' key is currently pressed.
```

Tokios išraiškos reikšmė yra `bool`{lang=python}. Visus mygtuko reikšmes rasite [pygame.key](https://www.pygame.org/docs/ref/key.html) dokumentacijoje. Anksčiau pateiktame pavyzdyje, matome daug sąlygos sakinių, kuriuose tikriname ar vienas iš :keyboard-keys{:keys='["W", "A", "S", "D"]' any} mygtukų paspaustas. Jeigu paspautas:

- :keyboard-keys{:keys='["W"]'}, tai prie žaidėjo pozicijos y koordinatės atimama $$300 \cdot dt$$ reikšmė;
- :keyboard-keys{:keys='["S"]'}, tai prie žaidėjo pozicijos y koordinatės pridedamas $$300 \cdot dt$$ reikšmė;
- :keyboard-keys{:keys='["A"]'}, tai prie žaidėjo pozicijos x koordinatės atimama $$300 \cdot dt$$ reikšmė;
- :keyboard-keys{:keys='["D"]'}, tai prie žaidėjo pozicijos x koordinatės pridedamas $$300 \cdot dt$$ reikšmė;

Skaičius $$300$$ yra greitis, šis greitis išreikštas, **šiuo atveju**, pikseliais per sekundę. Daugiklis dt yra kažkoks tai kiekis sekundėmis. Kaip šis apskaičiuojamas pasiaiškinsime vėliau. Pakeitus žaidėjo pozicijos kintamojo reikšmę, jo pozicija ekrane nesikeičia, mes pakeičiame tik kintamojo reikšmę. Ši reikšmė naudojama kitame cikle, ankstesnėje eilutėje `pygame.draw.circle(screen, "red", player_pos, 40)`{lang=python} - piešiamas toks pat apskritimas, bet jau kitoje pozicijoje. Tokiu būdu apskritimo pozicija žaidimo lange kinta.

Kodo pavyzdyje naudojama ir sutrumpinta sumos, atimties sintaksė. Vietoje:

```python
player_pos.y = player_pos.y + 300 * dt
```

Užrašoma (atkreipkite dėmesį į + priešais =):

```python
player_pos.y += 300 * dt
```

Daugiau apie tokią sintaksę galite pasiskaityti [čia](https://www.altcademy.com/blog/how-to-increment-in-python/).

### Kadravimo dažnis

Šis rodiklis dar gali būti pavadintas kadrais per sukundę (angl. *Frames Per Second*, *FPS*). Kadravimo dažnis rodo, kiek kartų per sekundę žaidimas atnaujina ir atvaizduoja naują kadrą. Didesnis FPS paprastai užtikrina sklandesnę animaciją ir sklandesnį žaidimą, o dėl mažesnio FPS žaidimas gali atrodyti trūkčiojantis ar vėluojantis.

Kuriant žaidimą, kadrai pasirodo ne vienodu intervalu, vienas gali pasirodyti per 0.1 sekundės, kitas per 0.05. Tarkime turime judėjimo greitį $$v=10$$, kol kas, tegul šis greitis reiškią nueitą kelią per kadrą. Pasižiūrėkime, kiek taškas nukeliaus atstumo $$\Delta x$$ ($$\Delta$$ - delta) per 5 kadrus (kadrų atvaizdavimo laikas $$t$$ parinktas atsitiktinai), jeigu šis juda greičiu $$v=10$$:

| Kadras | Kadras atvaizdavimo laikas $$t$$ | Atstumas $\Delta x$ |
| ------ | -------------------------------- | ------------------- |
| 0      | 0                                | 0                   |
| 1      | 0.1                              | 10                  |
| 2      | 0.22                             | 10                  |
| 3      | 0.31                             | 10                  |
| 4      | 0.39                             | 10                  |
| 5      | 0.49                             | 10                  |

5 kadrai buvo parodyti per $$t_{visas1}=0.49$$ sekundes, taškas nukeliavo $$\Delta x_1=10+10+10+10+10=50$$ pikselius (px). Skaičiuojant realesniais pasaulio matmenimis - pikseliais per sekunde $$px/s$$, greitis yra $$v_{r1}=\frac{\Delta x_1}{t_{visas1}}=\frac{50}{0.49}\approx102.04$$ $$px/s$$.

Dabar paanalizuokime kitą situaciją, vėl 5 kadrai, vėl tas pats greitis, bet dabar mūsų sistema apkrauta labiau, procesorius užimtas daugiau, o kadrai sugeneruojami lėčiau.

| Kadras | Kadras atvaizdavimo laikas $$t$$ | Atstumas $\Delta x$ |
| ------ | -------------------------------- | ------------------- |
| 0      | 0                                | 0                   |
| 1      | 0.2                              | 10                  |
| 2      | 0.43                             | 20                  |
| 3      | 0.61                             | 30                  |
| 4      | 0.71                             | 40                  |
| 5      | 0.83                             | 50                  |

5 kadrai buvo parodyti per $$t_{visas2}=0.83$$ sekundes, taškas nukeliavo tiek pat pikselių - $$50$$. Suskaičiuokime greitį $$px/s$$: $$v_{r2}=\frac{\Delta x_2}{t_{visas2}}=\frac{50}{0.83}\approx60.24$$ $$px/s$$.

Vienu atveju turime, kad per sekundę taškas nukeliaus $$102.04$$ pikselius, kitu atveju, kai sistema veikia lėčiau, $$60.24$$ pikselius. Tai nėra gerai, nes visi judėjimai priklausys nuo to, kaip greitai veikia sistema, kiek ji apkrauta, koks geras procesorius (CPU) ar vaizdo plokštė (GPU). Tokiai problemai spręsti, greitį reikia pririšti prie realaus pasaulio laiko. *Pygame* tai padaroma skaičiuojant laiką praėjusį nuo praeito kadro:

```python
    # ...
    # limits FPS to 60
    # dt is delta time in seconds since last frame, used for framerate-
    # independent physics.
    dt = clock.tick(60) / 1000

# ...
```

Kintamasis `dt`{lang=python} tariamas delta t. Šis skirtumas tarp kadrų atvaizdavimo laiko matematikoje gali būti užrašytas kaip $$\Delta t=t_{n}-t_{n-1}$$, čia $$\Delta t$$ praėjęs laikas tarp dviejų kadrų, $$t_{n-1}$$ - kadro prieš atvaizdavimo laikas, $$t_{n}$$ - kadro atvaizdavimo laikas. Tarkime turim du kadrus, vienas atvaizduotas žaidimo 10 sekundę, sekantis atvaizduotas žaidimo 10.2 sekundę, tai skirtumas tarp šių kadrų laiko yra $$\Delta t=10.2-10=0.2$$ sec. O tai reiškia, kad laikas nuo vieno kadro atvaizdavimo iki kito kadro atvaizdavimo yra $$0.2$$ sekundės.

*Pygame* kode `clock.tick(60)`{lang=python} vienetai yra milisekundės, todėl toliau padalinamas iš 1000, kad būtų gautos sekundės.

Toliau pažiūrėkime, kaip anksčiau pateiktoje lentelėje keisis skaičiai, kai skaičiuosime nuo to laiko, kuris praėjo tarp kadrų atvaizdavimo. Greitis $$v=10\;px/s$$.
| Kadras | Kadras atvaizdavimo momentas $$t$$ | $$\Delta t$$       | Atstumas $\Delta x = v\cdot t$ |
| ------ | ---------------------------------- | ------------------ | ------------------------------ |
| 0      | 0                                  | 0                  | 0                              |
| 1      | 0.2                                | $$0.2-0=0.2$$      | $$10 \cdot 0.2 = 2$$           |
| 2      | 0.43                               | $$0.43-0.2=0.23$$  | $$10 \cdot 0.23 = 2.3$$        |
| 3      | 0.61                               | $$0.61-0.43=0.18$$ | $$10 \cdot 0.18 = 1.8$$        |
| 4      | 0.71                               | $$0.71-0.61=0.1$$  | $$10 \cdot 0.1 = 1$$           |
| 5      | 0.83                               | $$0.83-0.71=0.12$$ | $$10 \cdot 0.12 = 1.2$$        |

Šiuo atveju nukeliautas atstumas $$\Delta x_3=2+2.3+1.8+1+1.2=8.3$$. Kad ir kaip keistųsi kadrų atvaizdavimo laikas, mūsų realus greitis pastovus ir nekintantis, nepriklausomai nuo sistemos pajėgumų.

Šis greitis anksčiau pateiktame kodo pavyzdyje yra $$300$$ pikseliai per sekundę, kuris yra padauginamas iš laiko tarp kadrų `player_pos.y += 300 * dt`{lang=python}. Kaip ir anksčiau, tai galima išreikšti ir formule $$layer\_pos\_y_{n}= player\_pos\_y_{n-1}+300 \cdot \Delta t$$.

## Užduotys

1. Pirma užduotis;
2. Pirma užduotis;
3. Trečia užduotis;
4. Ketvirta užduotis;
5. Penkta užduotis;
6. hdfgdf

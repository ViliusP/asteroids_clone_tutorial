---
title: 'Failų apdorojimas'
description: 'Bla bla bla'
draft: true
created_at: '2024-09-18'
updated_at: '2024-09-18'
authors:
  - 'Vilius Paliokas'
---

Išmoksime savo programoms suteikti daugiau dinamiškumo savo programoms - skaitysime iš failo ir įrašysime į failą.

## Keletas failų formatų

Pirma supažinkime su keleta failų formatų, kurios reiktų žinoti esant programuotoju. Nors susipažinsime su keleta, toliau dirbsime tik su vieno tipo *CSV*.

### Plėtinys

Prieš pereinant prie konkrečių tipų, reiktų išsiaiškinti formatą ir plėtinio skirtumus. Failams, kuriuose talpiname *Python* kodą, suteikiame vardą ir prirašome gale `.py`{ lang=text }. Ši failo pavadinimo dalis - galas vadinamas **plėtiniu** (*angl. extension*). Labai svarbu suprasti tai, kad **failo plėtinys nurodomas programoms, kad jos žinotų, ko tikėtis iš faile esančių duomenų** - kokia duomenų struktūrą ir ką jie reprezentuoja.

Jeigu sukurtume tekstinį failą pavadinimu `data.txt`{ lang=text }:

```text[data.txt]
Labas, mama.
```

Tai mūsų operacinė sistema bandant paleisti šį failą, atidarytų tekstinę rengyklę. Niekas nedraudžia šitam failui suteikti kitokį plėtinį:

```text[data.mp3]
Labas, mama.
```

Tokį failą operacinė sistema bandys atidaryti naudojant muzikos grotuvą. Atidarę turėtumėte pamatyti ekrane klaidą. Tokių failų apdorojimas vyksta priklausomai taip, kaip numatė jį programotuojas.  

Žemiau pateikta keletas plėtinių, kuriuos reiktų žinoti:

Dokumentų failai:

- `.txt`{lang=text}: paprastas tekstinis failas;
- `.pdf`{lang=text}: nešiojamojo dokumento formatas (*angl. Portable Document Format*);
- `.doc/.docx`{lang=text}: Microsoft Word dokumento failas;
- `.ppt/.pptxt`{lang=text}: Microsoft PowerPoint pateikčių failas;

Grafikos failai:

- `.jpg/.jpeg`{lang=text}: Joint Photographic Experts Group (atvaizdo formatas);
- `.png`{lang=text}: Portable Network Graphics (atvaizdo formatas);
- `.gif`{lang=text}: Graphics Interchange Format (atvaizdo formatas);
- `.bmp`{lang=text}: Bitmap image file (atvaizdo formatas);
- `.svg`{lang=text}: Scalable Vector Graphics (vektorinės grafikos formatas);
- `.webp`{lang=text}: Modernus atvaizdo formatas žiniatinkliui;

Audio ir video failai:

- `.mp3`{lang=text}: MPEG Audio Layer III (glaudtinas audio failų formatas);
- `.wav`{lang=text}: Waveform Audio File Format;
- `.flac`{lang=text}: Nemokamas glaudintas be praradimų (*angl. lossless*) audio kodekas (*angl. codec*);
- `.mp4`{lang=text}: MPEG-4 Part 14 (vienas iš populiaresnių failų formatų video medžiagai);
- `.webm`{lang=text}: Atviras video duomenų formatas žiniatinkliui;
- `.mkv`{lang=text}: Matroska Video (palaiko kelis garso ir subtitrų takelius);

Kita:

- `.xls/.xlsx`{lang=text}: Microsoft Excel skaičiuoklės failas;
- `.zip`: Glaudintas archyvinis failas;
- `.html`: HyperText Markup Language (Žymėjimo kalbos, naudojamo saitymo elementų atvaizdavimui, failas);
- `.css`: Cascading Style Sheets file (pakopinių stilių šablonų failas);
- `.rar`: RAR archyvinis failas;

Kiekvieno failo specifika skiriasi, tai išsiaiškinama, kada jie naudojami tiksliau ir kuo jie ypatingi, paliksime padaryti savarankiškai.

### Formatas

Failo formatas nurodo, kaip duomenys faile yra užkoduoti ir struktūrizuoti. Šis užkodavimas ir strūktura nulemia tai, kaip duomenys yra saugomi perskaitomi ir apdorojami programų. Kiekvienas failo formatas...

### JSON

d

### XML

c

### CSV

b

### Kita

a

## Skaitymas iš failo

Toliau visi darbai bus atliekami su `.csv`{ lang=python } failais. Padarysime taip, kad faile esantys duomenys, kaip kintamasis (-ieji), atsirastų mūsų programoje. Tokį perkėlimo veiksmą vadinsime failų nuskaitymu.

Kad atidarytumėme failą, jis turi egzistuoti jūsų įrenginyje, o kode tereikia panaudoti funkciją `open()`{ lang=python }:

```python
# In programming, there's a common convention to use 'f' as a short name for a file variable.
# This makes the code easier to read and understand for others who are familiar with this practice.
f = open("data.txt")
```

Tarkime, mūsų `data.txt`{ lang=text} faile yra toks tekstas:

```text[data.txt]
Hello, World!
```

Jeigu bandytume atspausdinti `f`{ lang=python } kintamąjį nepamatytumėme teksto. Pamatytumėte kažką panašaus į:

```console
<_io.TextIOWrapper name='data.txt' mode='r' encoding='UTF-8'>
```

Šiuo atveju kintamasis `f`{ lang=python } yra objektas (konkrečiau apie šią sąvoką sužinosite sekančiose pamokose), kuriame saugoma informacija apie atidarytą failą.

### `readline()`{ lang=python }

Anksčiau sukurtu objektu galime pasinaudoti, kad perskaitytumėme informaciją:

```python
f = open("data.txt")
line = f.readline()
print(line)
```

Terminale turėtumėte pamatyti mūsų tekstą `Hello, World!`{ lang=console }. Šitą eilutę iš duomenų failo gauname su `readline()`{ lang=python } metodu, o šis grąžina `string`{ lang=python } tipo reikšmę. Pagal pavadinimą, galite suprasti, kad perskaito vieną eilutę (ir tik vieną!).

#### Failo pabaiga

Kas bus jeigu perskaitysime daugiau eilučių negu yra faile?

```python
f = open("data.txt")
line = f.readline() # 1st read
print(line)

line = f.readline() # 2nd read
print(line)

line = f.readline() # 3rd read
print(line)
```

Metodas `readline()`{ lang=python } gražins tuščią eilutę `""`{ lang=python }:

```console
Hello, World!


⁤
```

Tai reiškias `readline()`{ lang=python } galima skaityti visą failą, o jeigu jis baigsis metodas gražins tuščią eilutę.

O kas jeigu faile kažkur viduryje yra tuščia eilutė?

#### Keletas `readline()`{ lang=python } iškvietimų

Tarkime turime didesnį failą:

```text[bigger_data.txt]
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

Kad galėtume su `readline()`{ lang=python } metodu perskaityti šešias eilutes, mums reikią šį metodą panaudoti penkis kartus. Perskaičius eilutę, kitą kartą skaitant, yra perskaitoma sekanti:

```python
f = open("bigger_data.txt")
print(f.readline()) # line 1
print(f.readline()) # line 2
print(f.readline()) # line 3
print(f.readline()) # line 4
print(f.readline()) # line 5
print(f.readline()) # line 6
```

Perskaičius ir atspausdintus 6 eilutes iš failo, gauname tokį rezultatą

```console
My mother was a tailor

She sewed my new blue jeans

My father was a gamblin' man

Down in New Orleans



Now the only thing a gambler needs
⁤
```

Gauname daug perteklinių tarpų. Jie atsiranda dėl to, kad faile, eilutės gale (ten, kur paspaudžiamas :keyboard-keys{:keys='["enter"]'} klavišas) yra naujos eilutės simbolis `\n`{ lang=text }. Tai `print()`{ lang=python } funkcija ir naujos eilutės simbolis `\n`{ lang=text } kartu duoda dvigubą naują eilutę. Kad jos išvengtume galima pašalinti iš perskaitytos eilutės tą simbolį arba `print()`{ lang=python } funkcijoje neišvedinėti (numatyto) naujos eilutės simbolio:

```python
f = open("bigger_data.txt")
print(f.readline().replace("\n", "")) # line 1, method 1
print(f.readline().replace("\n", "")) # line 2, method 1
print(f.readline().replace("\n", "")) # line 3, method 1
print(f.readline(), end="") # line 4, method 2
print(f.readline(), end="") # line 5, method 2
print(f.readline(), end="") # line 6, method 2
```

Dabar atspausdiname eilutes teisingai:

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
```

Atkreipkite dėmesį, kad tuščia eilutė irgi perskaitoma, nes ji yra mūsų duomenų faile.

#### Vienintelis argumentas

Šiam analizuojamam metodui galima pateikti vieną argumentą - skaičių, kuris nusako kiek bitų (dažnu atveju tai simbolių) reikia nuskaityti iš eilutės

```python
f = open("bigger_data.txt")
print(f.readline(12))
```

Bandydami nuskaityti pirmą eilutę ir įrašę, kad mums reikia 12 simbolių, gausime tokį rezultatą:

```console
My mother wa
```

Šitą metodą tikriausiai teks naudoti retai.

### `readlines()`{ lang=python }

Jeigu norime nuskaityti iš karto visas failo eilutes, galime pasinaudoti `readlines()` metodu. Šis metodas grąžina visas failo eilutes sąraše:

```python
f = open("bigger_data.txt")
print(f.readlines())
```

```console
['My mother was a tailor\n', 'She sewed my new blue jeans\n', "My father was a gamblin' man\n", 'Down in New Orleans\n', '\n', 'Now the only thing a gambler needs\n', 'Is a suitcase and a trunk\n', "And the only time he's satisfied\n", "Is when he's on a trump\n", 'Oh mother, tell your children\n', 'Not to do what I have done\n', 'Spend your lives in sin and misery\n', 'In the house of The Rising Sun']
```

Problema ta, kad kiekviena eilutė, jeigu po jos yra sekanti, turi naujos eilutės simbolį `\n`{ lang=text }. Šią problemą išmoksime spręsti vėliau.

Šiam metodui irgi galima suteikti vieną argumentą, kuris taip pat nurodo, kiek bitų (simbolių ) nuskaityti.

### `read()`{ lang=python }

Su `read()`{ lang=python } metodu galima nuskaityti visą failą ir šis metodas mums grąžins vieną eilutės reikšmę, kuriame bus visas mūsų tekstas:

```python
f = open("bigger_data.txt")
print(f.read())
```

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

### Iteravimas per objektą

Galima pasinaudoti ciklu ir failo objektu, jeigu yra poreikis iteruoti per eilutes:

```python
f = open("bigger_data.txt")
for line in f:
    print(line, end="")
```

Gauname tokį patį rezultatą, kaip ir su ankstesniais būdais

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

## Failo uždarymas su `close()`{ lang=python }

Nuo šio poskyrio, visada uždarinėsime atidarytą failą su `close()`{ lang=python } metodu. Tai padarysime, kai iš atidaryto failo mums nieko nebereikės, visas darbas su juo bus atliktas:

```python{4}
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()
```

Tik reiktų suprasti tai, kad failas nebebus pasiekiamas jį uždarius. Pabandykime perskaityti uždarytą failą: 

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

# This will cause an error because the file is already closed
print(f.readline())
```

Turėtumėte pamatyti ganėtinai aiškią klaidą:

```console
ValueError: I/O operation on closed file.
```

### Motyvai

Neišradinėsime dviračio ir pateiksime motyvus, kodėl reikia uždarinėti fialus, iš *Stack Overflow*:

> For the most part, not closing files is a bad idea, for the following reasons:
>
> 1. It puts your program in the garbage collectors hands - though the file in theory will be auto closed, it may not be closed. Python 3 and Cpython generally do a pretty good job at garbage collecting, but not always, and other variants generally suck at it.
> 2. It can slow down your program. Too many things open, and thus more used space in the RAM, will impact performance.
> 3. For the most part, many changes to files in python do not go into effect until after the file is closed, so if your script edits, leaves open, and reads a file, it won't see the edits.
> 4. You could, theoretically, run in to limits of how many files you can have open.
> 5. As @sai stated below, Windows treats open files as locked, so legit things like AV scanners or other python scripts can't read the file.
> 6. It is sloppy programming (then again, I'm not exactly the best at remembering to close files myself!)
>
> from [Why should I close files in Python? - Stack Overflow](https://stackoverflow.com/a/25070939)

Jeigu naudojami žodžiai sudėtingi, tai paprastai tariant:

- Tai yra programavimo geroji praktika;
- Uždaroma dėl programos greitaveikos;
- Gali kilti išorinių problemų, nes atidaromas failas yra užrakinamas tos programos, kuri tą failą ir atidaro. Tokiu atveju kitos programos negali jo atidaryti.

### Raktažodis `with`{ lang=python }

*Python* kalboje uždarymą galima atlikti ir automatiškai su `with`{ lang=python } raktažodžiu. Kodą, kurį rašėme anksčiau:

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

print("The file is now closed and cannot be accessed anymore")
```

Galima pakeisti į funkcionaliai lygiavertį atitikmenį:

```python
# Pay attention to the indentation inside the 'with' block
with open("bigger_data.txt") as f:
  print(f.readline()) # This line is indented, this indicates it belongs to the 'with' block

print("The file is now closed and cannot be accessed anymore") # This line isn't indented, it does not belong to the 'with' block
```

Su raktažodžiu `with`{ lang=python } mes sukuriame bloką, kuriame galima pasiekti failo kintamąjį, kurį aprašome su `as f`{ lang=python }. Kintamojo pavadinimą galima keisti, tai galite padaryti tiesiog pakeitus `f`{ lang=python } į kažką kitą:

```python
with open("bigger_data.txt") as song_lyrics_file:
  print(song_lyrics_file.readline()) 
```

## Apdorojimas

Nuo čia ir toliau analizuosime, kaip apdoroti tik `.csv`{ lang=python } failus. Tarkime turime klientų sąrašą (15 eilučių - 15 klientų), kuriame pateiktas vardas, pavardė, amžius, el. paštas, šalis, telefono numeris:

```text[customers.csv]
Renaud,Dispencer,46,rdispencer0@live.com,China,+86 474 126 7611
Misty,Cuttler,54,mcuttler1@bing.com,China,+86 599 457 8677
Merry,Mcettrick,70,mmcettrick2@woothemes.com,China,+86 306 934 3204
Ruby,Trulocke,33,rtrulocke3@acquirethisname.com,Poland,+48 186 302 8630
Ahmed,Dossett,26,adossett4@cdc.gov,Belarus,+375 170 210 1648
Taryn,Eayrs,36,teayrs5@chicagotribune.com,China,+86 201 744 4817
Armin,Starie,52,astarie6@com.com,United Arab Emirates,+971 135 992 7474
Arron,Beauvais,60,abeauvais7@networksolutions.com,Philippines,+63 245 245 6107
Ulrick,Ellsbury,67,uellsbury8@mayoclinic.com,France,+33 124 167 9435
Louise,McGiff,52,lmcgiff9@naver.com,Sri Lanka,+94 752 778 0341
Loise,Farris,56,lfarrisa@census.gov,Brazil,+55 124 687 2374
Conny,Aloshkin,70,caloshkinb@state.tx.us,China,+86 788 945 5235
Jedidiah,Pemberton,37,jpembertonc@blog.com,Japan,+81 266 348 0766
Willdon,Deboy,25,wdeboyd@forbes.com,Indonesia,+62 155 660 7974
Cleopatra,McMaster,55,cmcmastere@nps.gov,Japan,+81 255 140 4796
```

Tekstinius duomenis turėtume mokėti perskaityti:

```python
f = open("bigger_data.txt")
raw_data = f.readlines()
f.close()
```

Kadangi mūsų `raw_data`{ lang=python} turi nereikalingų naujos eilutės simbolių `\n`{ lang=text }, jį pašalinkime:

```python

```


### Ę

a

## Rašymas į failą

c

## Užduotys

### 1. a

a

### 2. b

b

### 3. c

c

### 4. d

d
=======
## Keletas failų tipai

## Skaitymas iš failo

### Apdorojimas

### 

##

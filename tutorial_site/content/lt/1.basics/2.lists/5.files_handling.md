---
title: 'Failų apdorojimas'
description: 'Bla bla bla'
draft: true
created_at: '2024-09-18'
updated_at: '2024-09-18'
authors:
  - 'Vilius Paliokas'
---

Išmoksime savo programoms suteikti daugiau dinamiškumo savo programoms - skaitysime iš failo ir įrašysime į failą.

## Keletas failų formatų

Pirma supažinkime su keleta failų formatų, kurios reiktų žinoti esant programuotoju. Nors susipažinsime su keleta, toliau dirbsime tik su vieno tipo *CSV*.

### Plėtinys

Prieš pereinant prie konkrečių tipų, reiktų išsiaiškinti formatą ir plėtinio skirtumus. Failams, kuriuose talpiname *Python* kodą, suteikiame vardą ir prirašome gale `.py`{ lang=text }. Ši failo pavadinimo dalis - galas vadinamas **plėtiniu** (*angl. extension*). Labai svarbu suprasti tai, kad **failo plėtinys nurodomas programoms, kad jos žinotų, ko tikėtis iš faile esančių duomenų** - kokia duomenų struktūrą ir ką jie reprezentuoja.

Jeigu sukurtume tekstinį failą pavadinimu `data.txt`{ lang=text }:

```text[data.txt]
Labas, mama.
```

Tai mūsų operacinė sistema bandant paleisti šį failą, atidarytų tekstinę rengyklę. Niekas nedraudžia šitam failui suteikti kitokį plėtinį:

```text[data.mp3]
Labas, mama.
```

Tokį failą operacinė sistema bandys atidaryti naudojant muzikos grotuvą. Atidarę turėtumėte pamatyti ekrane klaidą. Tokių failų apdorojimas vyksta priklausomai taip, kaip numatė jį programotuojas.  

Žemiau pateikta keletas plėtinių, kuriuos reiktų žinoti:

Dokumentų failai:

- `.txt`{lang=text}: paprastas tekstinis failas;
- `.pdf`{lang=text}: nešiojamojo dokumento formatas (*angl. Portable Document Format*);
- `.doc/.docx`{lang=text}: Microsoft Word dokumento failas;
- `.ppt/.pptxt`{lang=text}: Microsoft PowerPoint pateikčių failas;

Grafikos failai:

- `.jpg/.jpeg`{lang=text}: Joint Photographic Experts Group (atvaizdo formatas);
- `.png`{lang=text}: Portable Network Graphics (atvaizdo formatas);
- `.gif`{lang=text}: Graphics Interchange Format (atvaizdo formatas);
- `.bmp`{lang=text}: Bitmap image file (atvaizdo formatas);
- `.svg`{lang=text}: Scalable Vector Graphics (vektorinės grafikos formatas);
- `.webp`{lang=text}: Modernus atvaizdo formatas žiniatinkliui;

Audio ir video failai:

- `.mp3`{lang=text}: MPEG Audio Layer III (glaudtinas audio failų formatas);
- `.wav`{lang=text}: Waveform Audio File Format;
- `.flac`{lang=text}: Nemokamas glaudintas be praradimų (*angl. lossless*) audio kodekas (*angl. codec*);
- `.mp4`{lang=text}: MPEG-4 Part 14 (vienas iš populiaresnių failų formatų video medžiagai);
- `.webm`{lang=text}: Atviras video duomenų formatas žiniatinkliui;
- `.mkv`{lang=text}: Matroska Video (palaiko kelis garso ir subtitrų takelius);

Kita:

- `.xls/.xlsx`{lang=text}: Microsoft Excel skaičiuoklės failas;
- `.zip`: Glaudintas archyvinis failas;
- `.html`: HyperText Markup Language (Žymėjimo kalbos, naudojamo saitymo elementų atvaizdavimui, failas);
- `.css`: Cascading Style Sheets file (pakopinių stilių šablonų failas);
- `.rar`: RAR archyvinis failas;

Kiekvieno failo specifika skiriasi, tai išsiaiškinama, kada jie naudojami tiksliau ir kuo jie ypatingi, paliksime padaryti savarankiškai.

### Formatas

Failo formatas nurodo, kaip duomenys faile yra užkoduoti ir struktūrizuoti. Šis užkodavimas ir strūktura nulemia tai, kaip duomenys yra saugomi, perskaitomi ir apdorojami programų. Kiekvienas failo formatas...

### CSV

b

### JSON

d

### XML

c

### Kita

a

## Skaitymas iš failo

Toliau visi darbai bus atliekami su `.csv`{ lang=python } failais. Padarysime taip, kad faile esantys duomenys, kaip kintamasis (-ieji), atsirastų mūsų programoje. Tokį perkėlimo veiksmą vadinsime failų nuskaitymu.

Kad atidarytumėme failą, jis turi egzistuoti jūsų įrenginyje, o kode tereikia panaudoti funkciją `open()`{ lang=python }:

```python
# In programming, there's a common convention to use 'f' as a short name for a file variable.
# This makes the code easier to read and understand for others who are familiar with this practice.
f = open("data.txt")
```

Tarkime, mūsų `data.txt`{ lang=text} faile yra toks tekstas:

```text[data.txt]
Hello, World!
```

Jeigu bandytume atspausdinti `f`{ lang=python } kintamąjį nepamatytumėme teksto. Pamatytumėte kažką panašaus į:

```console
<_io.TextIOWrapper name='data.txt' mode='r' encoding='UTF-8'>
```

Šiuo atveju kintamasis `f`{ lang=python } yra objektas (konkrečiau apie šią sąvoką sužinosite sekančiose pamokose), kuriame saugoma informacija apie atidarytą failą.

### `readline()`{ lang=python }

Anksčiau sukurtu objektu galime pasinaudoti, kad perskaitytumėme informaciją:

```python
f = open("data.txt")
line = f.readline()
print(line)
```

Terminale turėtumėte pamatyti mūsų tekstą `Hello, World!`{ lang=console }. Šitą eilutę iš duomenų failo gauname su `readline()`{ lang=python } metodu, o šis grąžina `string`{ lang=python } tipo reikšmę. Pagal pavadinimą, galite suprasti, kad perskaito vieną eilutę (ir tik vieną!).

#### Failo pabaiga

Kas bus jeigu perskaitysime daugiau eilučių negu yra faile?

```python
f = open("data.txt")
line = f.readline() # 1st read
print(line)

line = f.readline() # 2nd read
print(line)

line = f.readline() # 3rd read
print(line)
```

Metodas `readline()`{ lang=python } gražins tuščią eilutę `""`{ lang=python }:

```console
Hello, World!


⁤
```

Tai reiškias `readline()`{ lang=python } galima skaityti visą failą, o jeigu jis baigsis metodas gražins tuščią eilutę.

O kas jeigu faile kažkur viduryje yra tuščia eilutė?

#### Keletas `readline()`{ lang=python } iškvietimų

Tarkime turime didesnį failą:

```text[bigger_data.txt]
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

Kad galėtume su `readline()`{ lang=python } metodu perskaityti šešias eilutes, mums reikią šį metodą panaudoti penkis kartus. Perskaičius eilutę, kitą kartą skaitant, yra perskaitoma sekanti:

```python
f = open("bigger_data.txt")
print(f.readline()) # line 1
print(f.readline()) # line 2
print(f.readline()) # line 3
print(f.readline()) # line 4
print(f.readline()) # line 5
print(f.readline()) # line 6
```

Perskaičius ir atspausdintus 6 eilutes iš failo, gauname tokį rezultatą

```console
My mother was a tailor

She sewed my new blue jeans

My father was a gamblin' man

Down in New Orleans



Now the only thing a gambler needs
⁤
```

Gauname daug perteklinių tarpų. Jie atsiranda dėl to, kad faile, eilutės gale (ten, kur paspaudžiamas :keyboard-keys{:keys='["enter"]'} klavišas) yra naujos eilutės simbolis `\n`{ lang=text }. Tai `print()`{ lang=python } funkcija ir naujos eilutės simbolis `\n`{ lang=text } kartu duoda dvigubą naują eilutę. Kad jos išvengtume galima pašalinti iš perskaitytos eilutės tą simbolį arba `print()`{ lang=python } funkcijoje neišvedinėti (numatyto) naujos eilutės simbolio:

```python
f = open("bigger_data.txt")
print(f.readline().replace("\n", "")) # line 1, method 1
print(f.readline().replace("\n", "")) # line 2, method 1
print(f.readline().replace("\n", "")) # line 3, method 1
print(f.readline(), end="") # line 4, method 2
print(f.readline(), end="") # line 5, method 2
print(f.readline(), end="") # line 6, method 2
```

Dabar atspausdiname eilutes teisingai:

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
```

Atkreipkite dėmesį, kad tuščia eilutė irgi perskaitoma, nes ji yra mūsų duomenų faile.

#### Vienintelis argumentas

Šiam analizuojamam metodui galima pateikti vieną argumentą - skaičių, kuris nusako kiek bitų (dažnu atveju tai simbolių) reikia nuskaityti iš eilutės

```python
f = open("bigger_data.txt")
print(f.readline(12))
```

Bandydami nuskaityti pirmą eilutę ir įrašę, kad mums reikia 12 simbolių, gausime tokį rezultatą:

```console
My mother wa
```

Šitą metodą tikriausiai teks naudoti retai.

### `readlines()`{ lang=python }

Jeigu norime nuskaityti iš karto visas failo eilutes, galime pasinaudoti `readlines()` metodu. Šis metodas grąžina visas failo eilutes sąraše:

```python
f = open("bigger_data.txt")
print(f.readlines())
```

```console
['My mother was a tailor\n', 'She sewed my new blue jeans\n', "My father was a gamblin' man\n", 'Down in New Orleans\n', '\n', 'Now the only thing a gambler needs\n', 'Is a suitcase and a trunk\n', "And the only time he's satisfied\n", "Is when he's on a trump\n", 'Oh mother, tell your children\n', 'Not to do what I have done\n', 'Spend your lives in sin and misery\n', 'In the house of The Rising Sun']
```

Problema ta, kad kiekviena eilutė, jeigu po jos yra sekanti, turi naujos eilutės simbolį `\n`{ lang=text }. Šią problemą išmoksime spręsti vėliau.

Šiam metodui irgi galima suteikti vieną argumentą, kuris taip pat nurodo, kiek bitų (simbolių ) nuskaityti.

### `read()`{ lang=python }

Su `read()`{ lang=python } metodu galima nuskaityti visą failą ir šis metodas mums grąžins vieną eilutės reikšmę, kuriame bus visas mūsų tekstas:

```python
f = open("bigger_data.txt")
print(f.read())
```

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

### Iteravimas per objektą

Galima pasinaudoti ciklu ir failo objektu, jeigu yra poreikis iteruoti per eilutes:

```python
f = open("bigger_data.txt")
for line in f:
    print(line, end="")
```

Gauname tokį patį rezultatą, kaip ir su ankstesniais būdais

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

## Failo uždarymas su `close()`{ lang=python }

Nuo šio poskyrio, visada uždarinėsime atidarytą failą su `close()`{ lang=python } metodu. Tai padarysime, kai iš atidaryto failo mums nieko nebereikės, visas darbas su juo bus atliktas:

```python{4}
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()
```

Tik reiktų suprasti tai, kad failas nebebus pasiekiamas jį uždarius. Pabandykime perskaityti uždarytą failą:

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

# This will cause an error because the file is already closed
print(f.readline())
```

Turėtumėte pamatyti ganėtinai aiškią klaidą:

```console
ValueError: I/O operation on closed file.
```

### Motyvai

Neišradinėsime dviračio ir pateiksime motyvus, kodėl reikia uždarinėti fialus, iš *Stack Overflow*:

> For the most part, not closing files is a bad idea, for the following reasons:
>
> 1. It puts your program in the garbage collectors hands - though the file in theory will be auto closed, it may not be closed. Python 3 and Cpython generally do a pretty good job at garbage collecting, but not always, and other variants generally suck at it.
> 2. It can slow down your program. Too many things open, and thus more used space in the RAM, will impact performance.
> 3. For the most part, many changes to files in python do not go into effect until after the file is closed, so if your script edits, leaves open, and reads a file, it won't see the edits.
> 4. You could, theoretically, run in to limits of how many files you can have open.
> 5. As @sai stated below, Windows treats open files as locked, so legit things like AV scanners or other python scripts can't read the file.
> 6. It is sloppy programming (then again, I'm not exactly the best at remembering to close files myself!)
>
> from [Why should I close files in Python? - Stack Overflow](https://stackoverflow.com/a/25070939)

Jeigu naudojami žodžiai sudėtingi, tai paprastai tariant:

- Tai yra programavimo geroji praktika;
- Uždaroma dėl programos greitaveikos;
- Gali kilti išorinių problemų, nes atidaromas failas yra užrakinamas tos programos, kuri tą failą ir atidaro. Tokiu atveju kitos programos negali jo atidaryti.

### Raktažodis `with`{ lang=python }

*Python* kalboje uždarymą galima atlikti ir automatiškai su `with`{ lang=python } raktažodžiu. Kodą, kurį rašėme anksčiau:

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

print("The file is now closed and cannot be accessed anymore")
```

Galima pakeisti į funkcionaliai lygiavertį atitikmenį:

```python
# Pay attention to the indentation inside the 'with' block
with open("bigger_data.txt") as f:
  print(f.readline()) # This line is indented, this indicates it belongs to the 'with' block

print("The file is now closed and cannot be accessed anymore") # This line isn't indented, it does not belong to the 'with' block
```

Su raktažodžiu `with`{ lang=python } mes sukuriame bloką, kuriame galima pasiekti failo kintamąjį, kurį aprašome su `as f`{ lang=python }. Kintamojo pavadinimą galima keisti, tai galite padaryti tiesiog pakeitus `f`{ lang=python } į kažką kitą:

```python
with open("bigger_data.txt") as song_lyrics_file:
  print(song_lyrics_file.readline()) 
```

## Apdorojimas

Nuo čia ir toliau analizuosime, kaip apdoroti tik `.csv`{ lang=python } failus. Tarkime turime klientų sąrašą (15 eilučių - 15 klientų), kuriame pateiktas vardas, pavardė, amžius, el. paštas, šalis, telefono numeris:

```text [customers.csv]
Renaud,Dispencer,46,rdispencer0@live.com,China,+86 474 126 7611
Misty,Cuttler,54,mcuttler1@bing.com,China,+86 599 457 8677
Merry,Mcettrick,70,mmcettrick2@woothemes.com,China,+86 306 934 3204
Ruby,Trulocke,33,rtrulocke3@acquirethisname.com,Poland,+48 186 302 8630
Ahmed,Dossett,26,adossett4@cdc.gov,Belarus,+375 170 210 1648
Taryn,Eayrs,36,teayrs5@chicagotribune.com,China,+86 201 744 4817
Armin,Starie,52,astarie6@com.com,United Arab Emirates,+971 135 992 7474
Arron,Beauvais,60,abeauvais7@networksolutions.com,Philippines,+63 245 245 6107
Ulrick,Ellsbury,67,uellsbury8@mayoclinic.com,France,+33 124 167 9435
Louise,McGiff,52,lmcgiff9@naver.com,Sri Lanka,+94 752 778 0341
Loise,Farris,56,lfarrisa@census.gov,Brazil,+55 124 687 2374
Conny,Aloshkin,70,caloshkinb@state.tx.us,China,+86 788 945 5235
Jedidiah,Pemberton,37,jpembertonc@blog.com,Japan,+81 266 348 0766
Willdon,Deboy,25,wdeboyd@forbes.com,Indonesia,+62 155 660 7974
Cleopatra,McMaster,55,cmcmastere@nps.gov,Japan,+81 255 140 4796
```

Tekstinius duomenis turėtume mokėti perskaityti:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()
```

### Pradinis sutvarkymas

Kadangi mūsų `raw_data`{ lang=python} turi nereikalingų naujos eilutės simbolių `\n`{ lang=text }, jį pašalinkime:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

for i in range(len(raw_data)):
    raw_data[i] = raw_data[i].replace("\n", "")

print(raw_data)
```

Gauname švaresnias eilutes:

```console
['Renaud,Dispencer,46,rdispencer0@live.com,China,+86 474 126 7611', 'Misty,Cuttler,54,mcuttler1@bing.com,China,+86 599 457 8677', 'Merry,Mcettrick,70,mmcettrick2@woothemes.com,China,+86 306 934 3204', 'Ruby,Trulocke,33,rtrulocke3@acquirethisname.com,Poland,+48 186 302 8630', 'Ahmed,Dossett,26,adossett4@cdc.gov,Belarus,+375 170 210 1648', 'Taryn,Eayrs,36,teayrs5@chicagotribune.com,China,+86 201 744 4817', 'Armin,Starie,52,astarie6@com.com,United Arab Emirates,+971 135 992 7474', 'Arron,Beauvais,60,abeauvais7@networksolutions.com,Philippines,+63 245 245 6107', 'Ulrick,Ellsbury,67,uellsbury8@mayoclinic.com,France,+33 124 167 9435', 'Louise,McGiff,52,lmcgiff9@naver.com,Sri Lanka,+94 752 778 0341', 'Loise,Farris,56,lfarrisa@census.gov,Brazil,+55 124 687 2374', 'Conny,Aloshkin,70,caloshkinb@state.tx.us,China,+86 788 945 5235', 'Jedidiah,Pemberton,37,jpembertonc@blog.com,Japan,+81 266 348 0766', 'Willdon,Deboy,25,wdeboyd@forbes.com,Indonesia,+62 155 660 7974', 'Cleopatra,McMaster,55,cmcmastere@nps.gov,Japan,+81 255 140 4796']
```

Dabar galima atskirti eilutėse kableliais atskirtus duomenis.

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data=[]

for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data) 
    print(line_data)
```

Sukūrime sąrašus sąraše ir todėl galima pasiekti kiekvieną atskirą duomenų laukelį:

```console
['Renaud', 'Dispencer', '46', 'rdispencer0@live.com', 'China', '+86 474 126 7611']
['Misty', 'Cuttler', '54', 'mcuttler1@bing.com', 'China', '+86 599 457 8677']
['Merry', 'Mcettrick', '70', 'mmcettrick2@woothemes.com', 'China', '+86 306 934 3204']
['Ruby', 'Trulocke', '33', 'rtrulocke3@acquirethisname.com', 'Poland', '+48 186 302 8630']
['Ahmed', 'Dossett', '26', 'adossett4@cdc.gov', 'Belarus', '+375 170 210 1648']
['Taryn', 'Eayrs', '36', 'teayrs5@chicagotribune.com', 'China', '+86 201 744 4817']
['Armin', 'Starie', '52', 'astarie6@com.com', 'United Arab Emirates', '+971 135 992 7474']
['Arron', 'Beauvais', '60', 'abeauvais7@networksolutions.com', 'Philippines', '+63 245 245 6107']
['Ulrick', 'Ellsbury', '67', 'uellsbury8@mayoclinic.com', 'France', '+33 124 167 9435']
['Louise', 'McGiff', '52', 'lmcgiff9@naver.com', 'Sri Lanka', '+94 752 778 0341']
['Loise', 'Farris', '56', 'lfarrisa@census.gov', 'Brazil', '+55 124 687 2374']
['Conny', 'Aloshkin', '70', 'caloshkinb@state.tx.us', 'China', '+86 788 945 5235']
['Jedidiah', 'Pemberton', '37', 'jpembertonc@blog.com', 'Japan', '+81 266 348 0766']
['Willdon', 'Deboy', '25', 'wdeboyd@forbes.com', 'Indonesia', '+62 155 660 7974']
['Cleopatra', 'McMaster', '55', 'cmcmastere@nps.gov', 'Japan', '+81 255 140 4796']
```

Toliau galima naudodami ciklą cikle skaičiuoti įverčius, apdoroti duomenis.

### Atvaizdavimas lentele

Naudojantis `f-strings`{ lang=python } tokius duomenis galima pateikti lentele:

```python [pretty_table.py]
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Data clean
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for line in data:
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |"
    formatted_lines.append(f_line)

# Printing
seperator_line = "-"*len(formatted_lines[0])
print(seperator_line)
for i, line in enumerate(formatted_lines):
    print(line)
    if(i == 0):
        print(seperator_line)
print(seperator_line)
```

```console
----------------------------------------------------------------------------------------------------------------
| Name       | Surname    | Age |                            Email |              Country |        Tel. Number |
----------------------------------------------------------------------------------------------------------------
| Renaud     | Dispencer  |  46 |             rdispencer0@live.com |                China |   +86 474 126 7611 |
| Misty      | Cuttler    |  54 |               mcuttler1@bing.com |                China |   +86 599 457 8677 |
| Merry      | Mcettrick  |  70 |        mmcettrick2@woothemes.com |                China |   +86 306 934 3204 |
| Ruby       | Trulocke   |  33 |   rtrulocke3@acquirethisname.com |               Poland |   +48 186 302 8630 |
| Ahmed      | Dossett    |  26 |                adossett4@cdc.gov |              Belarus |  +375 170 210 1648 |
| Taryn      | Eayrs      |  36 |       teayrs5@chicagotribune.com |                China |   +86 201 744 4817 |
| Armin      | Starie     |  52 |                 astarie6@com.com | United Arab Emirates |  +971 135 992 7474 |
| Arron      | Beauvais   |  60 |  abeauvais7@networksolutions.com |          Philippines |   +63 245 245 6107 |
| Ulrick     | Ellsbury   |  67 |        uellsbury8@mayoclinic.com |               France |   +33 124 167 9435 |
| Louise     | McGiff     |  52 |               lmcgiff9@naver.com |            Sri Lanka |   +94 752 778 0341 |
| Loise      | Farris     |  56 |              lfarrisa@census.gov |               Brazil |   +55 124 687 2374 |
| Conny      | Aloshkin   |  70 |           caloshkinb@state.tx.us |                China |   +86 788 945 5235 |
| Jedidiah   | Pemberton  |  37 |             jpembertonc@blog.com |                Japan |   +81 266 348 0766 |
| Willdon    | Deboy      |  25 |               wdeboyd@forbes.com |            Indonesia |   +62 155 660 7974 |
| Cleopatra  | McMaster   |  55 |               cmcmastere@nps.gov |                Japan |   +81 255 140 4796 |
----------------------------------------------------------------------------------------------------------------
```

### Vidurkio skaičiavimas

Kai jau turime sutvarkytus duomenis sąraše, juos galima pasiekti ir apskaičiuoti mums rūpimus įverčius. Apskaičiuokime klientų amžiaus vidurkį:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Clean the data
for i in range(len(raw_data)):
    line_data = raw_data[i].strip().split(",")
    data.append(line_data)

# Calculate the average age
age_sum = 0
for customer in data:
    # The third field (index=2) contains age information
    age_sum += int(customer[2])

print(f"Average age of customers: {age_sum / len(data):.1f}")
```

Gauname, kad mūsų klientų amžiaus vidurkis yra:

```console
Average age of customers: 49.3
```

## Metodo open() *mode* argumentas

Kai *Python* kalboje rašome

```python line-numbers=false
f = open("customers.csv")
```

iš tikro yra įvykdomas metodas

```python line-numbers=false
f = open("customers.csv", "r")
```

Ši argumento reikšmė yra numatytoji (*angl. default*) ir jeigu nenurodoma kita, su tokia reikšme metodas yra įvykdomas. Antrasis argumentas yra įvardijamas, kaip būdas (*angl. mode*), kuris nurodo, kaip failas bus naudojamas.

Reikšmė `"r"`{ lang=python } nurodo, kad failas bus atidaromas skaitymui. 

| Item                  | Paaiškinimas                                                                                                                                                |
| :-------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `"r"`{ lang=python }  | Failas atidaromas skaitymui                                                                                                                                 |
| `"r+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Rašymas vykdomas failo pradžioje                                                                                    |
| `"w"`{ lang=python }  | Failas atidaromas rašymui. Ištrinami visi failo duomenys arba failas sukuriamas, jeigu jis neegzistuoja. Rašymas vykdomas failo **pradžioje**               |
| `"w+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Ištrinami visi failo duomenys arba failas sukuriamas, jeigu jis neegzistuoja.  Rašymas vykdomas failo **pradžioje** |
| `"a"`{ lang=python }  | Failas atidaromas rašymui. Failas sukuriamas, jeigu jis neegzistuoja. Rašymas vykdomas failo **pabaigoje**                                                  |
| `"a+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Failas sukuriamas, jeigu jis neegzistuoja.  Rašymas vykdomas failo **pabaigoje**                                    |

Iš šios lentelės galima išskirti pagrindinius taisykles:

- `"r"`{ lang=python } niekada nesukuria faila ir neištrina inforamcijos;
- `"w"`{ lang=python } visada ištrina esamą informaciją faile ir įrašymas pradedamas nuo *tuščio lapo*;
- `"a"`{ lang=python } atidaromas failas informacijos rašymui pridedant prie jau informacijos faile esamos;
- `"+"`{ lang=python } nurodo, kad failas bus atidaromas ir skaitymui, ir rašymui.

Kad lengviau įsimintumėte, reikia suprasti, kad šios raidės yra žodžių trumpiniai:

- `"r"`{ lang=python } *read*;
- `"w"`{ lang=python } *write*;
- `"a+"`{ lang=python } *append*.

Galite savarankiškai paekspermentuoti su skirtingais argumentais ir išbandyti nuskaityti ir įrašinėti duomenis iš failų. Kadangi dar nežinome, kad įrašyti duomenis į failą, einame į kitą skyrių.

## Rašymas į failą

Kaip galima skaityti iš failo, taip galima ir įrašyti. Tam naudosime metodą `write()`{ lang=python } ir  `"w"`{ lang=python } argumentą atidarant failą.

Paimkime anksčiau sukurtą kodą, kuris `.csv`{ lang=text } duomenis atvaizduoja lentele. Tik šį kartą rezultatus pateiksime faile:

```python [pretty_table.py] { 20-24, 26, 28-30 }
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Cleaning data
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for line in data:
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |"
    formatted_lines.append(f_line)

# Writing to the file
f_results = open("results.txt", "w")  # Opening the file for writing. It will create the file automatically if it does not exist

separator_line = "-" * len(formatted_lines[0]) + "\n"
f_results.write(separator_line)
for i, line in enumerate(formatted_lines):
    f_results.write(line + '\n')
    if i == 0:
        f_results.write(separator_line)
f_results.write(separator_line)
f_results.close()
```

Paleidus programą, turėtumėte pamatyti naujai atsiradusį failą `results.txt`{ lang=text }:

```text [results.txt]
----------------------------------------------------------------------------------------------------------------
| Name       | Surname    | Age |                            Email |              Country |        Tel. Number |
----------------------------------------------------------------------------------------------------------------
| Renaud     | Dispencer  |  46 |             rdispencer0@live.com |                China |   +86 474 126 7611 |
| Misty      | Cuttler    |  54 |               mcuttler1@bing.com |                China |   +86 599 457 8677 |
| Merry      | Mcettrick  |  70 |        mmcettrick2@woothemes.com |                China |   +86 306 934 3204 |
| Ruby       | Trulocke   |  33 |   rtrulocke3@acquirethisname.com |               Poland |   +48 186 302 8630 |
| Ahmed      | Dossett    |  26 |                adossett4@cdc.gov |              Belarus |  +375 170 210 1648 |
| Taryn      | Eayrs      |  36 |       teayrs5@chicagotribune.com |                China |   +86 201 744 4817 |
| Armin      | Starie     |  52 |                 astarie6@com.com | United Arab Emirates |  +971 135 992 7474 |
| Arron      | Beauvais   |  60 |  abeauvais7@networksolutions.com |          Philippines |   +63 245 245 6107 |
| Ulrick     | Ellsbury   |  67 |        uellsbury8@mayoclinic.com |               France |   +33 124 167 9435 |
| Louise     | McGiff     |  52 |               lmcgiff9@naver.com |            Sri Lanka |   +94 752 778 0341 |
| Loise      | Farris     |  56 |              lfarrisa@census.gov |               Brazil |   +55 124 687 2374 |
| Conny      | Aloshkin   |  70 |           caloshkinb@state.tx.us |                China |   +86 788 945 5235 |
| Jedidiah   | Pemberton  |  37 |             jpembertonc@blog.com |                Japan |   +81 266 348 0766 |
| Willdon    | Deboy      |  25 |               wdeboyd@forbes.com |            Indonesia |   +62 155 660 7974 |
| Cleopatra  | McMaster   |  55 |               cmcmastere@nps.gov |                Japan |   +81 255 140 4796 |
----------------------------------------------------------------------------------------------------------------
```

Programoje atlikome keletą modifikacijų:

1. Atidarėme rezultatų failą su `"w"`{ lang=python } (20 eil.);
2. Jam neegzistuojant, programa pati jį sukūrė (20 eil.);
3. Anksčiau `print()`{ lang=python } funkcija automatiškai sudėdavo `\n`{ lang=text } simbolius, o `write()`{ lang=python } metodas to nedaro, todėl įrašomoms eilutėms turėjom tą pridėti (23 ir 26 eil.);
4. \* 26 eilutėje `\n`{ lang=text } simbolio pridėjimą galėtume iškelti į 17 eilutę.;
5. Funkcijas `print()`{ lang=python } pakeitėme į `f_results.write()`{ lang=python } (24, 26, 28, 29 eil.).
6. **Uždarėme failą!** (30 eil.)

Reiktų pastebėti tai:

- modifikuojant išvesties tekstą ir paleidus programą, rezultatų failo turinys yra ištrinamas ir įrašomas naujas. Taip vyksta kiekviena kartą paleidus programą;
- netyčia užvadinus išvesties failą `customers.csv`{ lang=text} jūsų duomenų failo informacija būtų ištrinta. **Atsargiai nurodykite failo pavadinimą!**;
- naujas eilutes reikia įvesti rankiniu būdu.  

### Metodas `writeLines()`{ lang=python }

Jeigu turime sąrašą eilučių, kurias norime išvesti į išvestį, tą galime padaryti su `writeLines()`{ lang=python } metodu. Vėl pakeiskime anksčiau analizuotą kodą ir pritaikykime jį tam, kad galėtume panaudoti anksčiau minėtą metodą:

```python { 17, 20-23, 25-27}
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Cleaning data
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines for writing to the file
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for i, line in enumerate(data):
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |\n"
    formatted_lines.append(f_line)

separator_line = "-" * len(formatted_lines[0])
formatted_lines.append(separator_line)  # Adding separator at the bottom of the table
formatted_lines.insert(1, separator_line + '\n')  # Adding separator after the header row
formatted_lines.insert(0, separator_line + '\n')  # Adding separator before the header row

# Writing to the file
with open("results.txt", "w") as f_results:
    f_results.writelines(formatted_lines)
```

Visą išvesties formavimą perkelėme prieš failo įrašymą, o paskui jį tik įrašėme į failą:

1. Prie suformuotos eilutės pridėjome naujos eilutės simbolį `\n`{ lang=python } (17 eil.);
2. Skyriklių (brūkšnelių) eilutes įterpėme atskirai į išviesties eilučių sąrašą (20-23 eil.);
3. Failo atidarymą pakeitemė (dėl pavyzdžio) naudojant `with`{ lang=python } raktažodį (26 eil.);
4. Išvesčiai į failą pateikėme visą sąrašą eilučių, kurias norime įrašyti į failą (27 eil.)

### Duomenų pridėjimas prie failo

Kai naudojame `"w"`{ lang=python } argumentą, įrašymas visada prasideda nuo tuščio failo. Kartais reikia išlaikyti senąją informaciją, prie jos pridedant naująją. Dažnai to reikia, kai pildome išviestis žurnalą (*angl. log*). Tokie žurnalai leidžia pamatyti, kokie veiksmai buvo atlikti, kaip vyksta skaičiavimai ar atliekami veiksmai programoje. Turinys priklauso nuo pačio programuotojo.

Sukurkime paprastą programą, kuri, įvedant į terminalą, kelią skaičių laipsniu, kuris taip pat įvedamas į terminalą. Šioje programoje taip pat bus įvesties apsauga.

```python
print("-" * 50)
print("Program has started")
print("This program calculates the number c = a^b")
print("-" * 50)

a = None
while a is None:
    try:
        a_input=input("Enter number a: ")
        a=int(a_input)
    except:
        print("You entered a non-numeric value. Please try again.")

b = None 
while b is None:
    try:
        b_input=input("Enter number b: ")
        b=int(b_input)
    except:
        print("You entered a non-numeric value. Please try again.")

c=a**b

print("-"*50)
print(f"Your result c = {c}")
```

Kol kas mūsų programoje nėra išvesties į failą.  Padaryta taip, kad naudotojas turėtų įvedinėt skaičių tol, kol jis bus tinkamas. Įgyvendinkime registravimą į žurnalą. Jame registruosime įvykusias klaidas, rezultatus:

```python
from datetime import datetime

log = open("log.txt", "a")
log.write(f"info: program started at {datetime.today().strftime('%Y-%m-%d %H:%M:%S')}\n")

print("-" * 50)
print("Program has started")
print("This program calculates the number c = a^b")
print("-" * 50)

a = None
while a is None:
    try:
        a_input = input("Enter number a: ")
        log.write(f"info: user entered a as \"{a_input}\"\n")
        a = int(a_input)
    except:
        print("You entered a non-numeric value. Please try again.")
        log.write("error: a_input is not a number\n")

b = None
while b is None:
    try:
        b_input = input("Enter number b: ")
        log.write(f"info: user entered b as \"{b_input}\"\n")
        b = int(b_input)
    except:
        print("You entered a non-numeric value. Please try again.")
        log.write("error: b_input is not a number\n")

c = a ** b

print("-" * 50)
print(f"Your result c = {c}")
log.write(f"info: Calculation result: {a}**{b}={c}\n")
log.write("-" * 50 + "\n")
log.close()
```

Taip galima sekti programos veikimą ir saugoti tuos duomenis ilgame laikotarpyje.

```text [log.txt]
info: program started at 2024-09-23 15:43:25
info: user entered a as "5"
info: user entered b as "2"
info: Calculation result: 5**2=25
--------------------------------------------------
info: program started at 2024-09-23 15:43:30
info: user entered a as "non number"
error: a_input is not a number
info: user entered a as "probably not number"
error: a_input is not a number
info: user entered a as "10"
info: user entered b as b stands for banana
error: b_input is not a number
info: user entered b as "4"
info: Calculation result: 10**4=10000
--------------------------------------------------
info: program started at 2024-09-23 15:44:13
info: user entered a as "[15~b"
error: a_input is not a number
info: user entered a as "2"
info: user entered b as "a"
error: b_input is not a number
info: user entered b as "10"
info: Calculation result: 2**10=1024
--------------------------------------------------
```

## Užduotys

### 1. a

a

### 2. b

b

### 3. c

c

### 4. d

d

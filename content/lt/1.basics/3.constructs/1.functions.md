---
title: 'Funkcijos'
description: 'Bla bla bla'
draft: true
created_at: '2024-09-24'
updated_at: '2024-09-24'
authors:
  - 'Vilius Paliokas'
---

Sąvoką funkciją turėjote matyti iki šio momento daug kartų. Šį kartą būsime jų kūrėjai ir išsiaiškinsime, kaip jos veikia viduje.

Anksčiau funkciją naudojome, kaip juodą dėžę:

![Funkcija kaip juoda dėžė](/content_images/func_diagram.png "Funkcija kaip juoda dėžė"){ height=400 format="png" provider=cloudinary centered }

Čia *x* laikykime, kaip visumą argumentų, kuriuos rašėme į funkciją. Juoda dėžė tai funkcijos kodo eilutės, sakiniai, kurių kviesdami mes nematėme. Išvestis *y* yra tas rezultatas, kurį gaudavome iškvietę funkciją (kartais grąžinamos reikšmės gali nebūti, pvz. `print()`{ lang=python }). Mūsų užduotis - išmokti kurti tą juodą dėžę.

Dar galima funkciją įsivaizduoti, kaip mašiną, įrenginį gamykloje, kuriai vienoje vietoje duodami kažkokios tai žaliavos, o tos mašinos kitoje pusėje gaunami pabaigtas produktas. Tas grąžinimas yra tarsi galutinio produkto atkeliavimas konvejerio juosta.

## Tic-tac-toe perdarymas

Temoje „ciklas cikle“ turėjote padaryti *tic-tac-toe* žaidimą. Pabandysime keletą vietų perdaryti su funkcijomis. Pasiruoškite analizuotį didelį kiekį kodo.

```python [tic-tac-toe.py] {21-27, 70-78}
# 3x3 Tic-Tac-Toe board
board = [
    [' ', ' ', ' '],
    [' ', ' ', ' '],
    [' ', ' ', ' ']
]

game_running=True
print("-"*25)
print("Tic-Tac-Toe @ Vilijus")
print("-"*25)
print("Rules:")
print("1. First player is defined as P1 and he places \"X\" on the board;")
print("2. Second player is defined as P2 and he places \"O\" on the board;")
print("3. Enter coordinates in the format \"X,Y\"; for example, \"1,2\" - this represents the first row and the second column.")
print("="*50) 
print("")

print("Game Board:")

print("-"*13)
for row in board:
    for cell in row: 
        print(f"| {cell} ", end="")
    print("|")
    print("-"*13)
print()

i=0
while game_running:

    # Player 1 input processing
    P1_input_ok = False
    while not P1_input_ok:
        P1_input = input("Enter P1 (X) move: ")
        P1_input_split = P1_input.split(",")
        if(len(P1_input_split) != 2):
            print("Invalid coordinates entered!")
            continue
        P1_x = int(P1_input_split[0])
        P1_y = int(P1_input_split[1])
        if(not (1 <= P1_x <= 3 and 1 <= P1_y <= 3)):
            print("Coordinates are outside the board!")
            continue   
        if(board[P1_x-1][P1_y-1] != ' '):
            print("Cell is occupied!")
            continue
        board[P1_x-1][P1_y-1] = "X"
        P1_input_ok = True

    # Player 2 input processing
    P2_input_ok = False
    while not P2_input_ok and 4:
        P2_input = input("Enter P2 (0) move: ")
        P2_input_split = P2_input.split(",")
        if(len(P2_input_split) != 2):
            print("Invalid coordinates entered!")
            continue
        P2_x = int(P2_input_split[0])
        P2_y = int(P2_input_split[1])
        if(not (1 <= P2_x <= 3 and 1 <= P2_y <= 3)):
            print("Coordinates are outside the board!")
            continue   
        if(board[P2_x-1][P2_y-1] != ' '):
            print("Cell is occupied!")
            continue
        board[P2_x-1][P2_y-1] = "0"
        P2_input_ok = True

    # Game board drawing
    print("\nGame Board:")
    print("-"*13)
    for row in board:
        for cell in row: 
            print(f"| {cell} ", end="")
        print("|")
        print("-"*13)
    print()

    # Game winning condition 
    winners_status = ["", "", "", ""]

    # Check rows
    for row in board:
        if row[0] == row[1] == row[2] and row[0] != ' ':
            winners_status[0]=row[0]

    # Check columns
    for col in range(3):
        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != ' ':
            winners_status[1]=board[0][col]

    # Check diagonals
    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != ' ':
        winners_status[2]=board[0][0]  # Return the winning symbol (X or O)
    
    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != ' ':
        winners_status[3]=board[0][2]  # Return the winning symbol (X or O)

    if("X" in winners_status):
        print("Player 1 won the game")
        print("Congratulations!!!")
        game_running = False

    if("O" in winners_status):
        print("Player 2 won the game")
        print("Congratulations!!!")
        game_running = False

    i+=1
    if(i > 4):
        print("No more moves left; the game is ended.")
        game_running = False
```

Pažymėtos eilutės (21-27 ir 70-78) veikia taip pat. Programavime tokius pat veiksmus mums reikia atlikinėti dažnai. Kad nereiktų perrašinėti kodo, kuris veikia taip pat, programuotojai kuria funkcijas. Kol kas mes funkcijas kvietėme, bet dar nesusitikome jų aprašymų.

Pagrindiniai funkcijų principai:

- Funkcija **gali** grąžinti (funkcijos kvietimą galima panaudoti, kaip reikšmę) reikšmę, pvz.: `sum()`{ lang=python }, `avg()`{ lang=python }, `len()`{ lang=python ;
- Funkcija **gali** negrąžinti reikšmės, o tik atlikti veiksmus, pvz.: `print()`{ lang=python };
- Funkcija **turi būti** aprašyta anksčiau (aukščiau), negu ji iškviečiama (panaudojama);
- Funkcija **gali** turėti parametrus (tai, ką galima įrašyti į skliausteliius) arba gali neturėti;
- Funkcija **turėtų** būti sukurta vienai paskirčiai;
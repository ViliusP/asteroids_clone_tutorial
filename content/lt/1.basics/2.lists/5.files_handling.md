---
title: 'Failų apdorojimas'
description: 'Bla bla bla'
created_at: '2024-09-18'
updated_at: '2024-09-18'
authors:
  - 'Vilius Paliokas'
---

Išmoksime savo programoms suteikti daugiau dinamiškumo savo programoms - skaitysime iš failo ir įrašysime į failą.

## Keletas failų formatų

Pirma supažinkime su keleta failų formatų, kurios reiktų žinoti esant programuotoju. Nors susipažinsime su keleta, toliau dirbsime tik su vieno tipo *CSV*.

### Plėtinys

Prieš pereinant prie konkrečių tipų, reiktų išsiaiškinti formatą ir plėtinio skirtumus. Failams, kuriuose talpiname *Python* kodą, suteikiame vardą ir prirašome gale `.py`{ lang=text }. Ši failo pavadinimo dalis - galas vadinamas **plėtiniu** (*angl. extension*). Labai svarbu suprasti tai, kad **failo plėtinys nurodomas programoms, kad jos žinotų, ko tikėtis iš faile esančių duomenų** - kokia duomenų struktūrą ir ką jie reprezentuoja.

Jeigu sukurtume tekstinį failą pavadinimu `data.txt`{ lang=text }:

```text[data.txt]
Labas, mama.
```

Tai mūsų operacinė sistema bandant paleisti šį failą, atidarytų tekstinę rengyklę. Niekas nedraudžia šitam failui suteikti kitokį plėtinį:

```text[data.mp3]
Labas, mama.
```

Tokį failą operacinė sistema bandys atidaryti naudojant muzikos grotuvą. Atidarę turėtumėte pamatyti ekrane klaidą. Tokių failų apdorojimas vyksta priklausomai taip, kaip numatė jį programotuojas.  

Žemiau pateikta keletas plėtinių, kuriuos reiktų žinoti:

Dokumentų failai:

- `.txt`{lang=text}: paprastas tekstinis failas;
- `.pdf`{lang=text}: nešiojamojo dokumento formatas (*angl. Portable Document Format*);
- `.doc/.docx`{lang=text}: Microsoft Word dokumento failas;
- `.ppt/.pptxt`{lang=text}: Microsoft PowerPoint pateikčių failas;

Grafikos failai:

- `.jpg/.jpeg`{lang=text}: Joint Photographic Experts Group (atvaizdo formatas);
- `.png`{lang=text}: Portable Network Graphics (atvaizdo formatas);
- `.gif`{lang=text}: Graphics Interchange Format (atvaizdo formatas);
- `.bmp`{lang=text}: Bitmap image file (atvaizdo formatas);
- `.svg`{lang=text}: Scalable Vector Graphics (vektorinės grafikos formatas);
- `.webp`{lang=text}: Modernus atvaizdo formatas žiniatinkliui;

Audio ir video failai:

- `.mp3`{lang=text}: MPEG Audio Layer III (glaudtinas audio failų formatas);
- `.wav`{lang=text}: Waveform Audio File Format;
- `.flac`{lang=text}: Nemokamas glaudintas be praradimų (*angl. lossless*) audio kodekas (*angl. codec*);
- `.mp4`{lang=text}: MPEG-4 Part 14 (vienas iš populiaresnių failų formatų video medžiagai);
- `.webm`{lang=text}: Atviras video duomenų formatas žiniatinkliui;
- `.mkv`{lang=text}: Matroska Video (palaiko kelis garso ir subtitrų takelius);

Kita:

- `.xls/.xlsx`{lang=text}: Microsoft Excel skaičiuoklės failas;
- `.zip`: Glaudintas archyvinis failas;
- `.html`: HyperText Markup Language (Žymėjimo kalbos, naudojamo saitymo elementų atvaizdavimui, failas);
- `.css`: Cascading Style Sheets file (pakopinių stilių šablonų failas);
- `.rar`: RAR archyvinis failas;

Kiekvieno failo specifika skiriasi, tai išsiaiškinama, kada jie naudojami tiksliau ir kuo jie ypatingi, paliksime padaryti savarankiškai.

### Formatas

Failo formatas nurodo, kaip duomenys faile yra užkoduoti ir struktūrizuoti. Šis užkodavimas ir strūktura nulemia tai, kaip duomenys yra saugomi, perskaitomi ir apdorojami programų.

Toliau aptariami ir visi kiti formatai, dažniausiai, nėra priklausomi nuo programavimo kalbos ir naudojami įvairiose technologijose.

### CSV

CSV formatas išsišifruoja į ***c**omma-**s**eparated **v**alues* - kableliais atskirtos reikšmės. Pačiame pavadinime ir užkoduotas šio formato principas.

Tokio formato duomenis patogu atvaizduoti lentele. Tarkime turime tris mokinius, kurių duomenis atvaizduosime `csv`{ lang=text } formate. Pirmiausiai į juos pasižiūrėkime lentelėje:

| Vardas    | Gimimo metai | Vidurkis | Klasė |
| --------- | ------------ | -------- | ----- |
| Vilius    | 2002-15-10   | 5.7      | 11c   |
| Vilija    | 2009-07-11   | 9.5      | 4a    |
| Vilhelmas | 2007-09-08   | 6.6      | 9a    |

Tai šias reikšmes galima atvaizduoti atskirtas kabeliu:

```csv
Vardas,Gimimo metai,Vidurkis,Klasė
Vilius,2002-15-10,5.7,11c
Vilija,2009-07-11,9.5,4a
Vilhelmas,2007-09-08,6.6,9a
```

Pirmojoje eilutėje kartais galima surasti antraštę - joje aprašyta tai, ką galima rasti stulpeliuose, bet ji nėra būtina. Visos reikšmės yra atskirtos kableliais. Kartais tokio formato failuose prireikia panaudoti kablelį reikšmėje, todėl gali būti panaudoti kiti skyrikliai, pavyzdžiui kabliataškis, :keyboard-keys{:keys='["TAB"]'} tarpas arba reikšmės gali būti kabutėse:

```csv
Minna;Amor;"oL2(qa>"".""";100.153.143.133
Midge;Sainthill;nM5#{nQWB3I|BH;74.204.156.127
Alexio;Velden;eW2*&@wtS;54.231.124.180
Catharine;Fazzioli;xT4&_cfN;190.42.255.251
```

```csv
first_name,last_name,email,balance
Tommie,Erangey,terangey0@surveymonkey.com,"€3,99"
Gustav,Glauber,gglauber1@mtv.com,"€8,90"
Prisca,Jerrold,pjerrold2@yahoo.com,"€7,14"
```

### JSON

JSON (***J**ava*S*cript **O**bject **N**otation*) - struktūrizuotų duomenų formatas, dažniausiai naudojamas duomenų apsikeitimui tarp serverio ir naršyklės.

Dažniausiai internete, ten, kur keičiasi duomenys, jie į naršyklę atkeliaujau *JSON* formatu. Pavyzdžius, prisijungus prie paskyros tinklalapyje, puslapis gali gauti panašius duomenis į šiuos apie jūsų paskyrą:

```json
{
  "account": {
    "id": "123456",
    "username": "john_doe",
    "email": "john.doe@example.com",
    "created_at": "2023-01-15T10:00:00Z",
    "status": "active",
    "profile": {
      "first_name": "John",
      "last_name": "Doe",
      "bio": "Software developer and tech enthusiast.",
      "profile_picture": "https://example.com/images/john_doe.jpg"
    },
    "settings": {
      "language": "en",
      "notifications": {
        "email": true,
        "sms": false
      }
    },
    "transactions": [
      {
        "transaction_id": "tx123",
        "amount": 150.00,
        "date": "2023-09-01T12:30:00Z",
        "type": "deposit"
      },
      {
        "transaction_id": "tx124",
        "amount": -50.00,
        "date": "2023-09-10T15:45:00Z",
        "type": "withdrawal"
      }
    ]
  }
}
```

Šiame pavyzdyje:

- *account*: duomenys apie paskyrą;
- *id*: unikalus paskyros identifikatorius;
- ...
- *profile*: paskyros duomenys apie profilį;
- *settings*: nustatymai;
- *transactions*: transakcijų (sandorių) sąrašas, kurie priklauso paskyrai.

Paimkime paprastesnį pavyzdį:

```json
{
  "name": "Alice",
  "age": 30,
  "is_student": false,
  "favourite_fruits": ["apple", "banana", "cherry"]
}
```

Duomenys aprašyti *JSON* formatu prasideda figūriniais skliaustais `{}`. Toliau yra laukeliai: kairysis vadinamas raktu, dešinys - reikšme.

Raktai: *"name"*, *"age"*, *"is_student"*, *"favourite_fruits"*.

Reikšmės: *"Alice"*, *30*, *false*, *["apple", "banana", "cherry"]*.

Šis formatas palaiko keletą tipų:

- eilutės (*angl. string*): tekstiniai duomenys pateikti dvigubose kabutėse, pvz., "labas, pasauli";
- skaičiai: skaitiniai duomenys, pvz.: 42, 3.14;
- loginis (*angl. boolean*): vaizduoja *true* arba *false*;
- null: tuščia reikšmė;
- objektas (*angl. object*): reikšmių ir raktų rinkinys, kuris apskliaustas figūriniais skliaustais `{}`;
- rinkinys, sąrašas (*angl. array*): reikšmių sąrašas, kurios aprašomos skliaustuose `[]`.

Šio formato duomenų apdorojimas priklauso nuo programavimo kalbos.

### XML

`XML`{ lang=text } (angl. *e**X**tensible **M**arkup **L**anguage*) yra žymėjimo kalba ir failų formatas. Šis formatas pastaruoju metu tampa vis mažiau populiaresnis. Naudojamas duomenų saugojimui ir apsikeitimui.  Šis formatas pasižymi `<`,`>`,`/` simboliais:

```xml
<catalog>
  <book id="bk101">
    <author>Gambardella, Matthew</author>
    <title>XML Developer's Guide</title>
    <genre>Computer</genre>
    <price>44.95</price>
    <publish_date>2000-10-01</publish_date>
    <description>An in-depth look at creating applications 
    with XML.</description>
  </book>
  <book id="bk102">
    <author>Ralls, Kim</author>
    <title>Midnight Rain</title>
    <genre>Fantasy</genre>
    <price>5.95</price>
    <publish_date>2000-12-16</publish_date>
    <description>A former architect battles corporate zombies, 
    an evil sorceress, and her own childhood to become queen 
    of the world.</description>
  </book>
  <book id="bk103">
    <author>Corets, Eva</author>
    <title>Maeve Ascendant</title>
    <genre>Fantasy</genre>
    <price>5.95</price>
    <publish_date>2000-11-17</publish_date>
    <description>After the collapse of a nanotechnology 
    society in England, the young survivors lay the 
    foundation for a new society.</description>
  </book>
</catalog>
```

Tokio formato duomenys prasideda nuo šakninio (*angl. root*) elemento. Šiuo atveju tai `<catalog>...</catalog>`{ lang=xml }.  Nuo šakninio elemento toliau einantys elementai vadinami elementais vaikais (*angl. child*). Santykiams apibūdinti tarp elementų naudojamos sąvokos tėvinis (*angl. parent*) elementas, vaikas (*angl. child*), brolis (arba sesė, *angl. siblings*). Broliniai elementai yra tame pačiame lygyje esantys elementai.

Pavyzdžiui elementui `<book id="bk101">...</book>`{ lang=xml } tėvinis elementas yra `<catalog>...</catalog>`{ lang=xml }, `<author>Gambardella, Matthew</author>`{ lang=xml }, `<title>XML Developer's Guide</title>`{ lang=xml }, `<genre>Computer</genre>`{ lang=xml }, `<price>44.95</price>`{ lang=xml } ir kt. yra tarpusavyje broliniai elementai, o jiems tėvinis yra `<book id="bk101">...</book>`{ lang=xml }.

Elementai savyje gali turėti tekstinį turinį, pvz.: `Maeve Ascendant`{ lang=txt } arba atributus `id="bk103"`{ lang=xml }.

## Skaitymas iš failo

Toliau visi darbai bus atliekami su `.csv`{ lang=python } failais. Padarysime taip, kad faile esantys duomenys, kaip kintamasis (-ieji), atsirastų mūsų programoje. Tokį perkėlimo veiksmą vadinsime failų nuskaitymu.

Kad atidarytumėme failą, jis turi egzistuoti jūsų įrenginyje, o kode tereikia panaudoti funkciją `open()`{ lang=python }:

```python
# In programming, there's a common convention to use 'f' as a short name for a file variable.
# This makes the code easier to read and understand for others who are familiar with this practice.
f = open("data.txt")
```

Tarkime, mūsų `data.txt`{ lang=text} faile yra toks tekstas:

```text[data.txt]
Hello, World!
```

Jeigu bandytume atspausdinti `f`{ lang=python } kintamąjį nepamatytumėme teksto. Pamatytumėte kažką panašaus į:

```console
<_io.TextIOWrapper name='data.txt' mode='r' encoding='UTF-8'>
```

Šiuo atveju kintamasis `f`{ lang=python } yra objektas (konkrečiau apie šią sąvoką sužinosite sekančiose pamokose), kuriame saugoma informacija apie atidarytą failą.

### `readline()`{ lang=python }

Anksčiau sukurtu objektu galime pasinaudoti, kad perskaitytumėme informaciją:

```python
f = open("data.txt")
line = f.readline()
print(line)
```

Terminale turėtumėte pamatyti mūsų tekstą `Hello, World!`{ lang=console }. Šitą eilutę iš duomenų failo gauname su `readline()`{ lang=python } metodu, o šis grąžina `string`{ lang=python } tipo reikšmę. Pagal pavadinimą, galite suprasti, kad perskaito vieną eilutę (ir tik vieną!).

#### Failo pabaiga

Kas bus jeigu perskaitysime daugiau eilučių negu yra faile?

```python
f = open("data.txt")
line = f.readline() # 1st read
print(line)

line = f.readline() # 2nd read
print(line)

line = f.readline() # 3rd read
print(line)
```

Metodas `readline()`{ lang=python } gražins tuščią eilutę `""`{ lang=python }:

```console
Hello, World!


⁤
```

Tai reiškias `readline()`{ lang=python } galima skaityti visą failą, o jeigu jis baigsis metodas gražins tuščią eilutę.

O kas jeigu faile kažkur viduryje yra tuščia eilutė?

#### Keletas `readline()`{ lang=python } iškvietimų

Tarkime turime didesnį failą:

```text[bigger_data.txt]
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

Kad galėtume su `readline()`{ lang=python } metodu perskaityti šešias eilutes, mums reikią šį metodą panaudoti penkis kartus. Perskaičius eilutę, kitą kartą skaitant, yra perskaitoma sekanti:

```python
f = open("bigger_data.txt")
print(f.readline()) # line 1
print(f.readline()) # line 2
print(f.readline()) # line 3
print(f.readline()) # line 4
print(f.readline()) # line 5
print(f.readline()) # line 6
```

Perskaičius ir atspausdintus 6 eilutes iš failo, gauname tokį rezultatą

```console
My mother was a tailor

She sewed my new blue jeans

My father was a gamblin' man

Down in New Orleans



Now the only thing a gambler needs
⁤
```

Gauname daug perteklinių tarpų. Jie atsiranda dėl to, kad faile, eilutės gale (ten, kur paspaudžiamas :keyboard-keys{:keys='["enter"]'} klavišas) yra naujos eilutės simbolis `\n`{ lang=text }. Tai `print()`{ lang=python } funkcija ir naujos eilutės simbolis `\n`{ lang=text } kartu duoda dvigubą naują eilutę. Kad jos išvengtume galima pašalinti iš perskaitytos eilutės tą simbolį arba `print()`{ lang=python } funkcijoje neišvedinėti (numatyto) naujos eilutės simbolio:

```python
f = open("bigger_data.txt")
print(f.readline().replace("\n", "")) # line 1, method 1
print(f.readline().replace("\n", "")) # line 2, method 1
print(f.readline().replace("\n", "")) # line 3, method 1
print(f.readline(), end="") # line 4, method 2
print(f.readline(), end="") # line 5, method 2
print(f.readline(), end="") # line 6, method 2
```

Dabar atspausdiname eilutes teisingai:

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
```

Atkreipkite dėmesį, kad tuščia eilutė irgi perskaitoma, nes ji yra mūsų duomenų faile.

#### Vienintelis argumentas

Šiam analizuojamam metodui galima pateikti vieną argumentą - skaičių, kuris nusako kiek bitų (dažnu atveju tai simbolių) reikia nuskaityti iš eilutės

```python
f = open("bigger_data.txt")
print(f.readline(12))
```

Bandydami nuskaityti pirmą eilutę ir įrašę, kad mums reikia 12 simbolių, gausime tokį rezultatą:

```console
My mother wa
```

Šitą metodą tikriausiai teks naudoti retai.

### `readlines()`{ lang=python }

Jeigu norime nuskaityti iš karto visas failo eilutes, galime pasinaudoti `readlines()` metodu. Šis metodas grąžina visas failo eilutes sąraše:

```python
f = open("bigger_data.txt")
print(f.readlines())
```

```console
['My mother was a tailor\n', 'She sewed my new blue jeans\n', "My father was a gamblin' man\n", 'Down in New Orleans\n', '\n', 'Now the only thing a gambler needs\n', 'Is a suitcase and a trunk\n', "And the only time he's satisfied\n", "Is when he's on a trump\n", 'Oh mother, tell your children\n', 'Not to do what I have done\n', 'Spend your lives in sin and misery\n', 'In the house of The Rising Sun']
```

Problema ta, kad kiekviena eilutė, jeigu po jos yra sekanti, turi naujos eilutės simbolį `\n`{ lang=text }. Šią problemą išmoksime spręsti vėliau.

Šiam metodui irgi galima suteikti vieną argumentą, kuris taip pat nurodo, kiek bitų (simbolių ) nuskaityti.

### `read()`{ lang=python }

Su `read()`{ lang=python } metodu galima nuskaityti visą failą ir šis metodas mums grąžins vieną eilutės reikšmę, kuriame bus visas mūsų tekstas:

```python
f = open("bigger_data.txt")
print(f.read())
```

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

### Iteravimas per objektą

Galima pasinaudoti ciklu ir failo objektu, jeigu yra poreikis iteruoti per eilutes:

```python
f = open("bigger_data.txt")
for line in f:
    print(line, end="")
```

Gauname tokį patį rezultatą, kaip ir su ankstesniais būdais

```console
My mother was a tailor
She sewed my new blue jeans
My father was a gamblin' man
Down in New Orleans

Now the only thing a gambler needs
Is a suitcase and a trunk
And the only time he's satisfied
Is when he's on a trump
Oh mother, tell your children
Not to do what I have done
Spend your lives in sin and misery
In the house of The Rising Sun
```

## Failo uždarymas su `close()`{ lang=python }

Nuo šio poskyrio, visada uždarinėsime atidarytą failą su `close()`{ lang=python } metodu. Tai padarysime, kai iš atidaryto failo mums nieko nebereikės, visas darbas su juo bus atliktas:

```python{4}
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()
```

Tik reiktų suprasti tai, kad failas nebebus pasiekiamas jį uždarius. Pabandykime perskaityti uždarytą failą:

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

# This will cause an error because the file is already closed
print(f.readline())
```

Turėtumėte pamatyti ganėtinai aiškią klaidą:

```console
ValueError: I/O operation on closed file.
```

### Motyvai

Neišradinėsime dviračio ir pateiksime motyvus, kodėl reikia uždarinėti fialus, iš *Stack Overflow*:

> For the most part, not closing files is a bad idea, for the following reasons:
>
> 1. It puts your program in the garbage collectors hands - though the file in theory will be auto closed, it may not be closed. Python 3 and Cpython generally do a pretty good job at garbage collecting, but not always, and other variants generally suck at it.
> 2. It can slow down your program. Too many things open, and thus more used space in the RAM, will impact performance.
> 3. For the most part, many changes to files in python do not go into effect until after the file is closed, so if your script edits, leaves open, and reads a file, it won't see the edits.
> 4. You could, theoretically, run in to limits of how many files you can have open.
> 5. As @sai stated below, Windows treats open files as locked, so legit things like AV scanners or other python scripts can't read the file.
> 6. It is sloppy programming (then again, I'm not exactly the best at remembering to close files myself!)
>
> from [Why should I close files in Python? - Stack Overflow](https://stackoverflow.com/a/25070939)

Jeigu naudojami žodžiai sudėtingi, tai paprastai tariant:

- Tai yra programavimo geroji praktika;
- Uždaroma dėl programos greitaveikos;
- Gali kilti išorinių problemų, nes atidaromas failas yra užrakinamas tos programos, kuri tą failą ir atidaro. Tokiu atveju kitos programos negali jo atidaryti.

### Raktažodis `with`{ lang=python }

*Python* kalboje uždarymą galima atlikti ir automatiškai su `with`{ lang=python } raktažodžiu. Kodą, kurį rašėme anksčiau:

```python
f = open("bigger_data.txt")
print(f.readline())
# I don't need the file anymore, so I'm closing it to free up resources
f.close()

print("The file is now closed and cannot be accessed anymore")
```

Galima pakeisti į funkcionaliai lygiavertį atitikmenį:

```python
# Pay attention to the indentation inside the 'with' block
with open("bigger_data.txt") as f:
  print(f.readline()) # This line is indented, this indicates it belongs to the 'with' block

print("The file is now closed and cannot be accessed anymore") # This line isn't indented, it does not belong to the 'with' block
```

Su raktažodžiu `with`{ lang=python } mes sukuriame bloką, kuriame galima pasiekti failo kintamąjį, kurį aprašome su `as f`{ lang=python }. Kintamojo pavadinimą galima keisti, tai galite padaryti tiesiog pakeitus `f`{ lang=python } į kažką kitą:

```python
with open("bigger_data.txt") as song_lyrics_file:
  print(song_lyrics_file.readline()) 
```

## Apdorojimas

Nuo čia ir toliau analizuosime, kaip apdoroti tik `.csv`{ lang=python } failus. Tarkime turime klientų sąrašą (15 eilučių - 15 klientų), kuriame pateiktas vardas, pavardė, amžius, el. paštas, šalis, telefono numeris:

```csv [customers.csv]
Renaud,Dispencer,46,rdispencer0@live.com,China,+86 474 126 7611
Misty,Cuttler,54,mcuttler1@bing.com,China,+86 599 457 8677
Merry,Mcettrick,70,mmcettrick2@woothemes.com,China,+86 306 934 3204
Ruby,Trulocke,33,rtrulocke3@acquirethisname.com,Poland,+48 186 302 8630
Ahmed,Dossett,26,adossett4@cdc.gov,Belarus,+375 170 210 1648
Taryn,Eayrs,36,teayrs5@chicagotribune.com,China,+86 201 744 4817
Armin,Starie,52,astarie6@com.com,United Arab Emirates,+971 135 992 7474
Arron,Beauvais,60,abeauvais7@networksolutions.com,Philippines,+63 245 245 6107
Ulrick,Ellsbury,67,uellsbury8@mayoclinic.com,France,+33 124 167 9435
Louise,McGiff,52,lmcgiff9@naver.com,Sri Lanka,+94 752 778 0341
Loise,Farris,56,lfarrisa@census.gov,Brazil,+55 124 687 2374
Conny,Aloshkin,70,caloshkinb@state.tx.us,China,+86 788 945 5235
Jedidiah,Pemberton,37,jpembertonc@blog.com,Japan,+81 266 348 0766
Willdon,Deboy,25,wdeboyd@forbes.com,Indonesia,+62 155 660 7974
Cleopatra,McMaster,55,cmcmastere@nps.gov,Japan,+81 255 140 4796
```

Tekstinius duomenis turėtume mokėti perskaityti:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()
```

### Pradinis sutvarkymas

Kadangi mūsų `raw_data`{ lang=python} turi nereikalingų naujos eilutės simbolių `\n`{ lang=text }, jį pašalinkime:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

for i in range(len(raw_data)):
    raw_data[i] = raw_data[i].replace("\n", "")

print(raw_data)
```

Gauname švaresnias eilutes:

```console
['Renaud,Dispencer,46,rdispencer0@live.com,China,+86 474 126 7611', 'Misty,Cuttler,54,mcuttler1@bing.com,China,+86 599 457 8677', 'Merry,Mcettrick,70,mmcettrick2@woothemes.com,China,+86 306 934 3204', 'Ruby,Trulocke,33,rtrulocke3@acquirethisname.com,Poland,+48 186 302 8630', 'Ahmed,Dossett,26,adossett4@cdc.gov,Belarus,+375 170 210 1648', 'Taryn,Eayrs,36,teayrs5@chicagotribune.com,China,+86 201 744 4817', 'Armin,Starie,52,astarie6@com.com,United Arab Emirates,+971 135 992 7474', 'Arron,Beauvais,60,abeauvais7@networksolutions.com,Philippines,+63 245 245 6107', 'Ulrick,Ellsbury,67,uellsbury8@mayoclinic.com,France,+33 124 167 9435', 'Louise,McGiff,52,lmcgiff9@naver.com,Sri Lanka,+94 752 778 0341', 'Loise,Farris,56,lfarrisa@census.gov,Brazil,+55 124 687 2374', 'Conny,Aloshkin,70,caloshkinb@state.tx.us,China,+86 788 945 5235', 'Jedidiah,Pemberton,37,jpembertonc@blog.com,Japan,+81 266 348 0766', 'Willdon,Deboy,25,wdeboyd@forbes.com,Indonesia,+62 155 660 7974', 'Cleopatra,McMaster,55,cmcmastere@nps.gov,Japan,+81 255 140 4796']
```

Dabar galima atskirti eilutėse kableliais atskirtus duomenis.

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data=[]

for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data) 
    print(line_data)
```

Sukūrime sąrašus sąraše ir todėl galima pasiekti kiekvieną atskirą duomenų laukelį:

```console
['Renaud', 'Dispencer', '46', 'rdispencer0@live.com', 'China', '+86 474 126 7611']
['Misty', 'Cuttler', '54', 'mcuttler1@bing.com', 'China', '+86 599 457 8677']
['Merry', 'Mcettrick', '70', 'mmcettrick2@woothemes.com', 'China', '+86 306 934 3204']
['Ruby', 'Trulocke', '33', 'rtrulocke3@acquirethisname.com', 'Poland', '+48 186 302 8630']
['Ahmed', 'Dossett', '26', 'adossett4@cdc.gov', 'Belarus', '+375 170 210 1648']
['Taryn', 'Eayrs', '36', 'teayrs5@chicagotribune.com', 'China', '+86 201 744 4817']
['Armin', 'Starie', '52', 'astarie6@com.com', 'United Arab Emirates', '+971 135 992 7474']
['Arron', 'Beauvais', '60', 'abeauvais7@networksolutions.com', 'Philippines', '+63 245 245 6107']
['Ulrick', 'Ellsbury', '67', 'uellsbury8@mayoclinic.com', 'France', '+33 124 167 9435']
['Louise', 'McGiff', '52', 'lmcgiff9@naver.com', 'Sri Lanka', '+94 752 778 0341']
['Loise', 'Farris', '56', 'lfarrisa@census.gov', 'Brazil', '+55 124 687 2374']
['Conny', 'Aloshkin', '70', 'caloshkinb@state.tx.us', 'China', '+86 788 945 5235']
['Jedidiah', 'Pemberton', '37', 'jpembertonc@blog.com', 'Japan', '+81 266 348 0766']
['Willdon', 'Deboy', '25', 'wdeboyd@forbes.com', 'Indonesia', '+62 155 660 7974']
['Cleopatra', 'McMaster', '55', 'cmcmastere@nps.gov', 'Japan', '+81 255 140 4796']
```

Toliau galima naudodami ciklą cikle skaičiuoti įverčius, apdoroti duomenis.

### Atvaizdavimas lentele

Naudojantis `f-strings`{ lang=python } tokius duomenis galima pateikti lentele:

```python [pretty_table.py]
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Data clean
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for line in data:
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |"
    formatted_lines.append(f_line)

# Printing
seperator_line = "-"*len(formatted_lines[0])
print(seperator_line)
for i, line in enumerate(formatted_lines):
    print(line)
    if(i == 0):
        print(seperator_line)
print(seperator_line)
```

```console
----------------------------------------------------------------------------------------------------------------
| Name       | Surname    | Age |                            Email |              Country |        Tel. Number |
----------------------------------------------------------------------------------------------------------------
| Renaud     | Dispencer  |  46 |             rdispencer0@live.com |                China |   +86 474 126 7611 |
| Misty      | Cuttler    |  54 |               mcuttler1@bing.com |                China |   +86 599 457 8677 |
| Merry      | Mcettrick  |  70 |        mmcettrick2@woothemes.com |                China |   +86 306 934 3204 |
| Ruby       | Trulocke   |  33 |   rtrulocke3@acquirethisname.com |               Poland |   +48 186 302 8630 |
| Ahmed      | Dossett    |  26 |                adossett4@cdc.gov |              Belarus |  +375 170 210 1648 |
| Taryn      | Eayrs      |  36 |       teayrs5@chicagotribune.com |                China |   +86 201 744 4817 |
| Armin      | Starie     |  52 |                 astarie6@com.com | United Arab Emirates |  +971 135 992 7474 |
| Arron      | Beauvais   |  60 |  abeauvais7@networksolutions.com |          Philippines |   +63 245 245 6107 |
| Ulrick     | Ellsbury   |  67 |        uellsbury8@mayoclinic.com |               France |   +33 124 167 9435 |
| Louise     | McGiff     |  52 |               lmcgiff9@naver.com |            Sri Lanka |   +94 752 778 0341 |
| Loise      | Farris     |  56 |              lfarrisa@census.gov |               Brazil |   +55 124 687 2374 |
| Conny      | Aloshkin   |  70 |           caloshkinb@state.tx.us |                China |   +86 788 945 5235 |
| Jedidiah   | Pemberton  |  37 |             jpembertonc@blog.com |                Japan |   +81 266 348 0766 |
| Willdon    | Deboy      |  25 |               wdeboyd@forbes.com |            Indonesia |   +62 155 660 7974 |
| Cleopatra  | McMaster   |  55 |               cmcmastere@nps.gov |                Japan |   +81 255 140 4796 |
----------------------------------------------------------------------------------------------------------------
```

### Vidurkio skaičiavimas

Kai jau turime sutvarkytus duomenis sąraše, juos galima pasiekti ir apskaičiuoti mums rūpimus įverčius. Apskaičiuokime klientų amžiaus vidurkį:

```python
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Clean the data
for i in range(len(raw_data)):
    line_data = raw_data[i].strip().split(",")
    data.append(line_data)

# Calculate the average age
age_sum = 0
for customer in data:
    # The third field (index=2) contains age information
    age_sum += int(customer[2])

print(f"Average age of customers: {age_sum / len(data):.1f}")
```

Gauname, kad mūsų klientų amžiaus vidurkis yra:

```console
Average age of customers: 49.3
```

## Metodo open() *mode* argumentas

Kai *Python* kalboje rašome

```python line-numbers=false
f = open("customers.csv")
```

iš tikro yra įvykdomas metodas

```python line-numbers=false
f = open("customers.csv", "r")
```

Ši argumento reikšmė yra numatytoji (*angl. default*) ir jeigu nenurodoma kita, su tokia reikšme metodas yra įvykdomas. Antrasis argumentas yra įvardijamas, kaip būdas (*angl. mode*), kuris nurodo, kaip failas bus naudojamas.

Reikšmė `"r"`{ lang=python } nurodo, kad failas bus atidaromas skaitymui. 

| Item                  | Paaiškinimas                                                                                                                                                |
| :-------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `"r"`{ lang=python }  | Failas atidaromas skaitymui                                                                                                                                 |
| `"r+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Rašymas vykdomas failo pradžioje                                                                                    |
| `"w"`{ lang=python }  | Failas atidaromas rašymui. Ištrinami visi failo duomenys arba failas sukuriamas, jeigu jis neegzistuoja. Rašymas vykdomas failo **pradžioje**               |
| `"w+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Ištrinami visi failo duomenys arba failas sukuriamas, jeigu jis neegzistuoja.  Rašymas vykdomas failo **pradžioje** |
| `"a"`{ lang=python }  | Failas atidaromas rašymui. Failas sukuriamas, jeigu jis neegzistuoja. Rašymas vykdomas failo **pabaigoje**                                                  |
| `"a+"`{ lang=python } | Failas atidaromas skaitymui ir rašymui. Failas sukuriamas, jeigu jis neegzistuoja.  Rašymas vykdomas failo **pabaigoje**                                    |

Iš šios lentelės galima išskirti pagrindinius taisykles:

- `"r"`{ lang=python } niekada nesukuria faila ir neištrina inforamcijos;
- `"w"`{ lang=python } visada ištrina esamą informaciją faile ir įrašymas pradedamas nuo *tuščio lapo*;
- `"a"`{ lang=python } atidaromas failas informacijos rašymui pridedant prie jau informacijos faile esamos;
- `"+"`{ lang=python } nurodo, kad failas bus atidaromas ir skaitymui, ir rašymui.

Kad lengviau įsimintumėte, reikia suprasti, kad šios raidės yra žodžių trumpiniai:

- `"r"`{ lang=python } *read*;
- `"w"`{ lang=python } *write*;
- `"a+"`{ lang=python } *append*.

Galite savarankiškai paekspermentuoti su skirtingais argumentais ir išbandyti nuskaityti ir įrašinėti duomenis iš failų. Kadangi dar nežinome, kad įrašyti duomenis į failą, einame į kitą skyrių.

## Rašymas į failą

Kaip galima skaityti iš failo, taip galima ir įrašyti. Tam naudosime metodą `write()`{ lang=python } ir  `"w"`{ lang=python } argumentą atidarant failą.

Paimkime anksčiau sukurtą kodą, kuris `.csv`{ lang=text } duomenis atvaizduoja lentele. Tik šį kartą rezultatus pateiksime faile:

```python [pretty_table.py] { 20-24, 26, 28-30 }
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Cleaning data
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for line in data:
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |"
    formatted_lines.append(f_line)

# Writing to the file
f_results = open("results.txt", "w")  # Opening the file for writing. It will create the file automatically if it does not exist

separator_line = "-" * len(formatted_lines[0]) + "\n"
f_results.write(separator_line)
for i, line in enumerate(formatted_lines):
    f_results.write(line + '\n')
    if i == 0:
        f_results.write(separator_line)
f_results.write(separator_line)
f_results.close()
```

Paleidus programą, turėtumėte pamatyti naujai atsiradusį failą `results.txt`{ lang=text }:

```text [results.txt]
----------------------------------------------------------------------------------------------------------------
| Name       | Surname    | Age |                            Email |              Country |        Tel. Number |
----------------------------------------------------------------------------------------------------------------
| Renaud     | Dispencer  |  46 |             rdispencer0@live.com |                China |   +86 474 126 7611 |
| Misty      | Cuttler    |  54 |               mcuttler1@bing.com |                China |   +86 599 457 8677 |
| Merry      | Mcettrick  |  70 |        mmcettrick2@woothemes.com |                China |   +86 306 934 3204 |
| Ruby       | Trulocke   |  33 |   rtrulocke3@acquirethisname.com |               Poland |   +48 186 302 8630 |
| Ahmed      | Dossett    |  26 |                adossett4@cdc.gov |              Belarus |  +375 170 210 1648 |
| Taryn      | Eayrs      |  36 |       teayrs5@chicagotribune.com |                China |   +86 201 744 4817 |
| Armin      | Starie     |  52 |                 astarie6@com.com | United Arab Emirates |  +971 135 992 7474 |
| Arron      | Beauvais   |  60 |  abeauvais7@networksolutions.com |          Philippines |   +63 245 245 6107 |
| Ulrick     | Ellsbury   |  67 |        uellsbury8@mayoclinic.com |               France |   +33 124 167 9435 |
| Louise     | McGiff     |  52 |               lmcgiff9@naver.com |            Sri Lanka |   +94 752 778 0341 |
| Loise      | Farris     |  56 |              lfarrisa@census.gov |               Brazil |   +55 124 687 2374 |
| Conny      | Aloshkin   |  70 |           caloshkinb@state.tx.us |                China |   +86 788 945 5235 |
| Jedidiah   | Pemberton  |  37 |             jpembertonc@blog.com |                Japan |   +81 266 348 0766 |
| Willdon    | Deboy      |  25 |               wdeboyd@forbes.com |            Indonesia |   +62 155 660 7974 |
| Cleopatra  | McMaster   |  55 |               cmcmastere@nps.gov |                Japan |   +81 255 140 4796 |
----------------------------------------------------------------------------------------------------------------
```

Programoje atlikome keletą modifikacijų:

1. Atidarėme rezultatų failą su `"w"`{ lang=python } (20 eil.);
2. Jam neegzistuojant, programa pati jį sukūrė (20 eil.);
3. Anksčiau `print()`{ lang=python } funkcija automatiškai sudėdavo `\n`{ lang=text } simbolius, o `write()`{ lang=python } metodas to nedaro, todėl įrašomoms eilutėms turėjom tą pridėti (23 ir 26 eil.);
4. \* 26 eilutėje `\n`{ lang=text } simbolio pridėjimą galėtume iškelti į 17 eilutę.;
5. Funkcijas `print()`{ lang=python } pakeitėme į `f_results.write()`{ lang=python } (24, 26, 28, 29 eil.).
6. **Uždarėme failą!** (30 eil.)

Reiktų pastebėti tai:

- modifikuojant išvesties tekstą ir paleidus programą, rezultatų failo turinys yra ištrinamas ir įrašomas naujas. Taip vyksta kiekviena kartą paleidus programą;
- netyčia užvadinus išvesties failą `customers.csv`{ lang=text} jūsų duomenų failo informacija būtų ištrinta. **Atsargiai nurodykite failo pavadinimą!**;
- naujas eilutes reikia įvesti rankiniu būdu.  

### Metodas `writeLines()`{ lang=python }

Jeigu turime sąrašą eilučių, kurias norime išvesti į išvestį, tą galime padaryti su `writeLines()`{ lang=python } metodu. Vėl pakeiskime anksčiau analizuotą kodą ir pritaikykime jį tam, kad galėtume panaudoti anksčiau minėtą metodą:

```python { 17, 20-23, 25-27}
f = open("customers.csv")
raw_data = f.readlines()
f.close()

data = []

# Cleaning data
for i in range(len(raw_data)):
    line_data = raw_data[i].replace("\n", "").split(",")
    data.append(line_data)

# Formatting lines for writing to the file
formatted_lines = []
header = ["Name", "Surname", "Age", "Email", "Country", "Tel. Number"]
data.insert(0, header)
for i, line in enumerate(data):
    f_line = f"| {line[0]:10} | {line[1]:10} | {line[2]:>3} | {line[3]:>32} | {line[4]:>20} | {line[5]:>18} |\n"
    formatted_lines.append(f_line)

separator_line = "-" * len(formatted_lines[0])
formatted_lines.append(separator_line)  # Adding separator at the bottom of the table
formatted_lines.insert(1, separator_line + '\n')  # Adding separator after the header row
formatted_lines.insert(0, separator_line + '\n')  # Adding separator before the header row

# Writing to the file
with open("results.txt", "w") as f_results:
    f_results.writelines(formatted_lines)
```

Visą išvesties formavimą perkelėme prieš failo įrašymą, o paskui jį tik įrašėme į failą:

1. Prie suformuotos eilutės pridėjome naujos eilutės simbolį `\n`{ lang=python } (17 eil.);
2. Skyriklių (brūkšnelių) eilutes įterpėme atskirai į išviesties eilučių sąrašą (20-23 eil.);
3. Failo atidarymą pakeitemė (dėl pavyzdžio) naudojant `with`{ lang=python } raktažodį (26 eil.);
4. Išvesčiai į failą pateikėme visą sąrašą eilučių, kurias norime įrašyti į failą (27 eil.)

### Duomenų pridėjimas prie failo

Kai naudojame `"w"`{ lang=python } argumentą, įrašymas visada prasideda nuo tuščio failo. Kartais reikia išlaikyti senąją informaciją, prie jos pridedant naująją. Dažnai to reikia, kai pildome išviestis žurnalą (*angl. log*). Tokie žurnalai leidžia pamatyti, kokie veiksmai buvo atlikti, kaip vyksta skaičiavimai ar atliekami veiksmai programoje. Turinys priklauso nuo pačio programuotojo.

Sukurkime paprastą programą, kuri, įvedant į terminalą, kelią skaičių laipsniu, kuris taip pat įvedamas į terminalą. Šioje programoje taip pat bus įvesties apsauga.

```python
print("-" * 50)
print("Program has started")
print("This program calculates the number c = a^b")
print("-" * 50)

a = None
while a is None:
    try:
        a_input=input("Enter number a: ")
        a=int(a_input)
    except:
        print("You entered a non-numeric value. Please try again.")

b = None 
while b is None:
    try:
        b_input=input("Enter number b: ")
        b=int(b_input)
    except:
        print("You entered a non-numeric value. Please try again.")

c=a**b

print("-"*50)
print(f"Your result c = {c}")
```

Kol kas mūsų programoje nėra išvesties į failą.  Padaryta taip, kad naudotojas turėtų įvedinėt skaičių tol, kol jis bus tinkamas. Įgyvendinkime registravimą į žurnalą. Jame registruosime įvykusias klaidas, rezultatus:

```python
from datetime import datetime

log = open("log.txt", "a")
log.write(f"info: program started at {datetime.today().strftime('%Y-%m-%d %H:%M:%S')}\n")

print("-" * 50)
print("Program has started")
print("This program calculates the number c = a^b")
print("-" * 50)

a = None
while a is None:
    try:
        a_input = input("Enter number a: ")
        log.write(f"info: user entered a as \"{a_input}\"\n")
        a = int(a_input)
    except:
        print("You entered a non-numeric value. Please try again.")
        log.write("error: a_input is not a number\n")

b = None
while b is None:
    try:
        b_input = input("Enter number b: ")
        log.write(f"info: user entered b as \"{b_input}\"\n")
        b = int(b_input)
    except:
        print("You entered a non-numeric value. Please try again.")
        log.write("error: b_input is not a number\n")

c = a ** b

print("-" * 50)
print(f"Your result c = {c}")
log.write(f"info: Calculation result: {a}**{b}={c}\n")
log.write("-" * 50 + "\n")
log.close()
```

Taip galima sekti programos veikimą ir saugoti tuos duomenis ilgame laikotarpyje.

```text [log.txt]
info: program started at 2024-09-23 15:43:25
info: user entered a as "5"
info: user entered b as "2"
info: Calculation result: 5**2=25
--------------------------------------------------
info: program started at 2024-09-23 15:43:30
info: user entered a as "non number"
error: a_input is not a number
info: user entered a as "probably not number"
error: a_input is not a number
info: user entered a as "10"
info: user entered b as b stands for banana
error: b_input is not a number
info: user entered b as "4"
info: Calculation result: 10**4=10000
--------------------------------------------------
info: program started at 2024-09-23 15:44:13
info: user entered a as "[15~b"
error: a_input is not a number
info: user entered a as "2"
info: user entered b as "a"
error: b_input is not a number
info: user entered b as "10"
info: Calculation result: 2**10=1024
--------------------------------------------------
```

## Užduotys

### 1. Teksto dalių kiekis

Suskaičiuokite, kiek simbolių, žodžių, sakinių sudaro žemiau pateiktą tekstą:

```text [lorem_ipsum.txt]
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec vulputate tortor et accumsan porttitor. Fusce auctor consequat metus et sodales. Nam ac scelerisque ex, id condimentum velit. Donec eget mi sed mauris ultricies porta. Curabitur mollis est mauris, a faucibus metus interdum eu. Maecenas vel mi nunc. Nunc facilisis, dolor ut dapibus ultricies, nibh mauris condimentum eros, vel faucibus eros enim quis nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Nullam at turpis eros. Donec eu hendrerit mi. In hac habitasse platea dictumst. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Curabitur et mattis felis. Curabitur commodo interdum nisi, nec lacinia risus scelerisque in. Lorem ipsum dolor sit amet, consectetur adipiscing elit.

Fusce sodales, felis eleifend fringilla condimentum, dui nibh ultricies elit, sit amet elementum risus metus id mi. Praesent dapibus sapien eu velit imperdiet, eget hendrerit neque porta. Quisque tincidunt enim odio, id maximus nunc placerat at. Nullam ac dui turpis. Nullam ultrices scelerisque posuere. Cras quis nunc ante. Donec lobortis, lorem ultricies consectetur dapibus, ipsum odio tristique leo, laoreet ornare velit turpis vitae libero. Fusce at elit vitae massa tincidunt condimentum eget ac urna.

Aenean scelerisque auctor sem, sit amet finibus tortor pellentesque sit amet. Mauris ut ante euismod mauris hendrerit iaculis eget vitae magna. Integer sapien nisl, porta a auctor. 
```

### 1. Daugybos lentelė

Sudarykite daugybos lentelę, šią lentelę išsaugokite faile. Lentelės dydis turi būti įvedamas naudotojo:

Išvesties pavyzdys:

```console
Enter the size of the multiplication table: 13
Multiplication table of size 13 saved to 'multiplication_table.txt'.
```

Rezultatų failo pavyzdys:

```text [multiplcation_table.txt]
    ||   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |  11 |  12 |  13
----------------------------------------------------------------------------------
  1 ||   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |  11 |  12 |  13
  2 ||   2 |   4 |   6 |   8 |  10 |  12 |  14 |  16 |  18 |  20 |  22 |  24 |  26
  3 ||   3 |   6 |   9 |  12 |  15 |  18 |  21 |  24 |  27 |  30 |  33 |  36 |  39
  4 ||   4 |   8 |  12 |  16 |  20 |  24 |  28 |  32 |  36 |  40 |  44 |  48 |  52
  5 ||   5 |  10 |  15 |  20 |  25 |  30 |  35 |  40 |  45 |  50 |  55 |  60 |  65
  6 ||   6 |  12 |  18 |  24 |  30 |  36 |  42 |  48 |  54 |  60 |  66 |  72 |  78
  7 ||   7 |  14 |  21 |  28 |  35 |  42 |  49 |  56 |  63 |  70 |  77 |  84 |  91
  8 ||   8 |  16 |  24 |  32 |  40 |  48 |  56 |  64 |  72 |  80 |  88 |  96 | 104
  9 ||   9 |  18 |  27 |  36 |  45 |  54 |  63 |  72 |  81 |  90 |  99 | 108 | 117
 10 ||  10 |  20 |  30 |  40 |  50 |  60 |  70 |  80 |  90 | 100 | 110 | 120 | 130
 11 ||  11 |  22 |  33 |  44 |  55 |  66 |  77 |  88 |  99 | 110 | 121 | 132 | 143
 12 ||  12 |  24 |  36 |  48 |  60 |  72 |  84 |  96 | 108 | 120 | 132 | 144 | 156
 13 ||  13 |  26 |  39 |  52 |  65 |  78 |  91 | 104 | 117 | 130 | 143 | 156 | 169
```

Lentelės apipavidalinimą ir išvestį galite keisti savo nuožiūrą.

### 2. Netinkami slaptažodžiai

Iš pateikto sąrašo atrinkite asmenis, kurių slaptažodžiai netinkami - slaptažodį sudaro 5 ir mažiau simboliai, ir juos pateikite atskirame rezultatų faile.

```csv [passwords.csv]
first_name,last_name,password,email
Brook,Simonsen,p4IE,bsimonsen6@princeton.edu
Magdalena,Goggins,b8vh,mgoggins7@japanpost.jp
Riley,Freeburn,i0lLpM,rfreeburn8@so-net.ne.jp
Lelah,Deards,b1<f$#m1,ldeards9@foxnews.com
Keslie,Fevers,v5l1qin4,kfeversa@123-reg.co.uk
Darbie,Garland,d4Gd<#$,dgarlandb@cbslocal.com
Moselle,Adamou,e5$CNlH),madamouc@dot.gov
Yehudit,Darby,v3Kahb_.,ydarbyd@cbc.ca
Man,Icom,z8P*,micome@fda.gov
Leland,Eagland,n3*2Dl,leaglandf@sciencedirect.com
Julienne,Viveash,q0Ei`N3,jviveashg@w3.org
Sharona,Danihel,u4UPd,sdanihelh@blog.com
Carlina,Pressey,i8G'aiC!,cpresseyi@japanpost.jp
Morley,Baty,x3~'Pk6,mbatyj@edublogs.org
```

### 3. Defektai

Gamybinė įmonė registruoja gamyboje įvykusius defektus, kurie registruojami kokybės kontrolės proceso metu. Duomenys apima tokią informaciją kaip defekto tipas, aptikimo data, vieta gaminyje, sunkumo lygis, naudojamas patikrinimo metodas ir remonto išlaidos.

Duomenis atsisiųskite iš [google drive](https://drive.google.com/file/d/1HwYWDCK5CWYeEAXDzi0MWcmR8LjXUXlz/view?usp=sharing
) arba [kaggle.com](https://www.kaggle.com/datasets/fahmidachowdhury/manufacturing-defects/data)

Duomenys sudaryti iš 1000 eilučių `csv`{ lang=python } formatu ir 10 stulpelių:

- *defect_id*: unikalus defekto identifikatorius;
- *product_id*: produkto, kuriam įvyko defektas, identifikatorius;
- *defect_type*: defekto tipas;
- *defect_date*: defekto aptikimo data;
- *defect_location*: defekto lokacija produkte;
- *severity*: defekto sunkumo laipsnis;
- *inspection_method*: metodas naudotas defektui aptikti;
- *repair_cost*: patirti kaštai taisant defektą.

Toliau pateiktos užduotys, kurias galite daryti vienoje programoje - faile.

#### 4.1 Defektų kaina

Suskaičiuokite, kiek įmonei kainavo sutaisyti visus defektus. Rezultatą pateikite terminale.

#### 4.2 Vidutinė defektų kaina

Suskaičiuokite, kiek įmonei vidutiškai kainuoja sutaisyti defektą. Rezultatą pateikite terminale.

#### 4.3 Brangiausias defektas

Kokią didžiausią sumą įmonė išleido tvarkant defektą? Rezultatą pateikite terminale.

#### 4.4 Produktas 1

Gamybos vadovas nori įdėmiai paanalizuoti produkto, kurio identifikatorius yra `1`, duomenis. Sukurkite failą, kuriame būtų pateikti šio produkto defektų duomenys.

#### 4.5 Defektai pagal tipą

Žinoma, kad įmonė defektus skirsto į tris tipus: Structural, Functional, Cosmetic. Įmonėje šie defektai tvarkomi atskiruose padaliniuose. Padalinių vadovai prašo, kad duomenys apie defektus būtų pateikti tik tie, kurie priklauso jų padaliniui. Išskirstykite duomenis į tris atskirus failus: `structural.csv`{ lang=text }, `functional.csv`{ lang=text }, `cosmetic.csv`{ lang=text }.

#### 4.6 Defektų išlaidų dalis pagal tipą

Žinoma, kad įmonė defektai aptinkami trijose lokacijose: Component, Internal, Surface. Kokią dalį tvarkymo išlaidų patiria įmonė pagal defekto aptikimo lokaciją? Rezultatą pateikite terminale.

### 5. Nešiojamų kompiuterių kainos

Turime duomenis apie nešiojamų kompiuterių kainas, šiuos duomenis galite rasti [google drive](https://drive.google.com/file/d/1-DmmaOdzTuLAPTMFn7MWGxNhKtPlFjlT/view?usp=drive_link
) arba [kaggle.com](https://www.kaggle.com/datasets/owm4096/laptop-prices).

Duomenų faile rasite 1275 eilutes ir 23 stulpelius.

- Company: nešiojamo kompiuterio gamintojas;
- Product: prekės ženklas ir modelis;
- TypeName: nešiojamo kompiuterio tipas (Notebook, Ultrabook, Gaming ir t.t.);
- Inches: ekrano dydis;
- Ram: RAM kiekis nešiojamame kompiuteryje (gigabaitais);
- OS: įrašyta operacinė sistema;
- Weight: svoris kilogramais;
- Price_euros: kaina eurais;
- Screen: ekrano raiška (Standard, Full HD, 4K Ultra HD, Quad HD+);
- ScreenW: ekrano plotis (pikseliais);
- ScreenH: ekrano aukštis (pikseliais);
- Touchscreen: ar nešiojamasis kompiuteris turi jutiklinį ekraną;
- IPSpanel: ar nešiojamasis kompiuteris turi IPS tipo ekraną;
- RetinaDisplay: ar nešiojamasis kompiuteris turi retina tipo ekraną;
- CPU_company: procesoriaus gamintojas;
- CPU_freq: procesoriaus dažnis;
- CPU_model: procesoriaus modelis;
- PrimaryStorage: pagrindinės atminties dydis (GB);
- PrimaryStorageType: pagrindinės atminties tipas (HDD, SSD, Flash Storage, Hybrid);
- SecondaryStorage: kitos atminties dydis, jeigu egzistuoja (GB);
- SecondaryStorageType: kitos atminties tipas, jeigu egzistuoja (HDD, SSD, Hybrid, None);
- GPU_company: vaizdo plokštės gamintojas;
- GPU_model: vaizdo plokštės modelis.

Iš duomenų sudarykite ataskaitą (tekstinį failą), kuriame būtų:

- Vidutinis kompiuterio svoris;
- Kompiuterių kiekis be operacinės sistemos;
- Vidutinė kompiuterio kaina;
- lentelė su TOP10 brangiausių nešiojamų kompiuterių (pateikti kainą, pavadinimą, ekrano dydį, operacinę sistemą);
- lentelė su TOP10 pigiausių nešiojamų kompiuterių (pateikti kainą, pavadinimą, ekrano dydį, operacinę sistemą);
- lentelė, kurioje kompiuterių kaina skiriasi ne daugiau nei 100 nuo vidurkio, procesorius yra i5 arba i7, o pagrindinė atmintis yra SSD tipo (pateikti kainą, pavadinimą, ekrano dydį, operacinę sistemą);
